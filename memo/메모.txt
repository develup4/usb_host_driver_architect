본 유즈케이스는 고객이 음료ㅗ수 구입을 위해, 자판기에 동전을 투입하면 시작된다.
=> 어떤 액터가 어떤 이벤트에 의해서 시작하는지 정의도어야 함

What how주에  what에 집중 일단
분기하지말자 포함하지말고 다 서술하자 유즈케이스문서

동전을 투입한다 이런 액션단위로까지 유즈케이스가 될수는 없다.
음료수 구입 정도면 됨

=> 베이스 유즈케이스를 정해야함. 그 뒤에 멘덴토리인지 옵셔널인지 구분해서 확장
모든 유즈케이스는 초기 펑셔널 리콰이어먼트로의 백워드 트레이싱이 가능해야 한다.


요구공학에서 수강신청 예제랑 다른팀꺼도 참고해볼까



이해관계자? 클라이언트 소프트웨어 개발자, 디바이스 개발자, 하드웨어 개발자, 운영체제 개발자? 등등

\

도메인모델에서 밑에 안준형이처럼 사각형 20개 까는게 아니라 포함관계도 있고(컨트롤러가 엔티티를 가지고 있다던지 바운더리가 컨트롤러를 연결 등등)

스펙다보고 코드도 좀 보면
이거랑 조용진강의 과제하는거부터 봐보자 => 아니면 일단 대충 해놓고 체크리스트로 보는건 어떨지
Best Practice Associate Architect 양성과정 인증과제 Best Practice(안준형님/S.LSI, 2020-21년 C3차) => 조용진에 디바이스 드라이버 => 3라인 두번째


Best Practice Associate Architect 양성과정 인증과제 Best Practice(2019-20년 12차) => 우충기 => 볼만함
Best Practice Associate Architect 양성과정 인증과제 Best Practice(박병훈님/VD, 2020-21년 C2차) => 조용진꺼
Best Practice Associate Architect 양성과정 인증과제 Best Practice(안준형님/S.LSI, 2020-21년 C3차) => 조용진에 디바이스 드라이버
ssociate Architect 양성과정 인증과제 Best Practice(정도영님/네트워크, 2020-21년 C4차)


Architectural Driver나 ASR이나 비슷한거다. FR, QA, Constraints
ASR Architecturally significant requirement =>그래서 설계에 영향을 주는 요구사항만 있어야하나보다
-> Architectural decision에 영향을 준다.

속도에는 저속, 전속력, 고속이 있다.LOW-SPEED(키보드), FULL-SPEED(오디오), HIGH-SPEED(비디오)
=> 스펙 40페이지에 있고 속성부분에 품질 구성요소가 있는거 같다.
=> 품질시나리오가 각 3단계마다 따로 있어야할듯


41페이지에도 기능 요구사항이 많이 있다.
=> 최종 사용자와 분리된 전기 세부 정보(클라이언트가 신경안써도 되게 호스트단에서 끝 vbus랑 통신 네고)
자가 식별 주변 장치, 드라이버 및 구성에 대한 기능 자동 매핑
여러 대역폭 장치에 적합, 다중연결 가능
여러 데이터 및 메시지 스트림 전송 지원(메시지? 데이터?)
플러그앤플레이 아키텍처와 일치
기존 운영체제 인터페이스 활용
오류처리 오류보ㅓㄱ구 매커니즘이 내장(파이레벨?) ARQ이런거 가능한가?
버퍼처리를 위한 흐름제어 내장(파이레벨?)
광범위한 패킷 크기 지원
시스템에서 여러 호스트 컨트롤러를 지원하도록 아키텍쳐 업그레이드 가능



VBUS는 선이다. 외부 액터로 표현이 가능한가? 아닌거같음
USB를 통해 전원을 공급하는데 이 경우 버스 전원장치라고 하며, 자체 전원이 있는 장치의 경우 자체 전원 장치라고 한다.
=> 상위 클라이언트가 전력량에 대해서 몰라야된다 => 이것도 제약사항인데 뭔가 구조에 영향을 줄때 하라는데 역할을 호스트가 하게되니 영향을 주는거겠지?
Electrical details isolated from end user (e.g., bus terminations)




호스트 개발자는 5,6,7,8,10,11
디바이스는 5,9,10




루트 허브로부터 계층구조가 가능하지만 뎁스는 7까지만 가능하다.
=> 연결시 서브 연결도 받아들이는데 뎁스랑 개수를 입력받고 127개를 안넘는지 뎁스가 안큰지 확인해야 한다.





빼먹은 리콰이어먼트가 없는게 가장 중요함
18페이지 논리콰이어 카테고리


User Requirement Definition => 클라이언트나 시스템 사용자가 관심
1. 진료과별 월말 약제비 현황 보고서 작성

System Requirement Specification => 엔지니어가 관심
1.1
1.2
1.3
1.4
1.5 세부 작업 순서


펑셔널과 비펑셔널이 헷갈리면
=> 내가 실제 코딩을 해야하나 고민하면됨.
아닌것은 모두 논펑셔널

그리고 일반적으로 시스템 전반적으로 적용되어야하는 경우 논펑





모든 use case는 초기 functional
requirements로의 backward tracing이 가능해야 함
111,112페이지 좋네

118페이지 그림도

원래는 주로 시리얼 포트나 패러럴 포트 등의 데이터 입출력 단자에 연결하여 이용하는 주변 기기들을 좀 더 쉽게 이용하기 위해 만들어진 단자이다. 앞서 언급한 포트들은 역사가 오래되어 속도도 느리고 전원 공급도 되지 않으며, 개수도 매우 한정되면서 연결선은 굵고 포트 크기도 큰 등 다양한 단점이 있었으며 초보자들에게는 설치도 어려웠다. 당시 인텔의 아제이 바트(Ajay Bhatt)의 아내가 프린터 설치에 어려움을 겪었고, 그때마다 전화로 알려주느라 고생하던 아제이 바트가 기존의 연결 방식을 대체하기 위한 포트의 개발이 시작 되었다. 첫 등장은 인텔 최초의 USB 지원 칩셋인 430HX가 발표된 1996년이나 실질적으로 대략 1990년대 말~2000년대 초부터 보급이 시작되었다. 현재는 주변기기 연결 인터페이스의 사실상 독점적인 위치를 점하고 있으며, 대부분의 기기가 USB로 연결되어 데이터를 전송하거나 전원을 공급하는데 이용된다. 그야말로 명칭 그대로의 범용.


저장이 가능한 하드웨어가 있다면
노운 장치 저장해서 컨피그 빨리 안되나



허브는 디바이스를 연결해서 시스템에 포함시킬 수 있는 기능
뭔가 엔티티가 있긴 해야하네


버전에 따라 어댑터


위와 같은 문제를 해결하기 위해 추가로 전원공급장치를 따로 마련한, 일명 '유전원 허브'도 있다. 다만 유전원 허브는 허브 입장에서 들어오는 포트(=전원 공급)는 하나인데 나가는 포트는 여러 개이기 때문에 여러 포트에서 동시에 전원을 끌어다 쓰면 감당하기 힘들어서 만든 것이다. 때문에 몇몇 허브는 포트당 최대 전력이 2.5W인 경우가 있으니 만약 한 포트에서 2.5W 이상의 전력을 요구한다면 해당 기능을 지원하는 허브인지 잘 찾아봐야 한다
USB의 Power Delivery가 버전업 되면서 포트 하나로 고용량의 전력을 제공할 수 있게 되었다. 특히 USB-Type-C는 무려 100W까지 지원하므로 이젠 굳이 파워 케이블을 따로 사용해야할 이유가 없을 지경에까지 이르렀다. 대표적으로 USB 3.0을 사용하는 2.5인치 외장 하드디스크는 단 하나의 USB 3.0 포트로도 전원 공급에 문제가 없다. 노트북까지 USB-Type-C로 충전할 정도이니 기술의 발전이 새삼 놀라울 따름이다. 이미 2010년대 후반 시점에서도 상당수 울트라북이 USB-Type-C를 통한 충전을 지원한다.[4] 자세한 얘기는 하단의 USB Power Delivery 파트나 급속충전 문서를 참조.


USB는 케이블 하나로 데이터 통신과 전력 제공이 가능하다. 


USB 파워 딜리버리 기술은 기본적으로 충전기와 충전대상 기기가 서로 데이터를 주고받으며 전압과 전류를 조절하는 게 기본이 된다. 이를 적극 활용해 대륙에서는 USB-PD 트리거라고 하는 제품을 만들어 판매하고 있다. USB-Type-C 숫단자에 바로 회로가 달린 제품이 있는가 하면, 암단자에 회로가 달린 형식이 되어 중간에 USB-Type-C to C 케이블을 꽂아 사용할 수 있는 형태도 있다. 회로에 전압을 선택할 수 있는 조절장치가 있으며, 사용자는 적당히 마감을 하여 전압을 선택하고 적당한 DC출력 케이블을 납땜해 자유롭게 출력을 얻는 방식으로 사용할 수 있다. 이러한 회로를 사용해서 구형 DC단자를 사용하는 노트북을 PD 충전기로 충전하는 것도 가능하며, DC단자를 사용하는 여러 가정용 전자기기에 딸려오는 거추장스럽고 긴 파워서플라이를 떼어버리고 멀티포트 충전기의 놀고있는 PD 단자를 사용해서 전원을 공급하는 식으로 전원플러그를 확보하는 것도 가능하다.



또한 기기별로 단자를 구별할 필요가 없다는 점도 장점이다. 따라서 아무 구멍이나 놀고 있는 데 끼워 넣으면 그만. 예전에 컴퓨터에서 프린터 단자, 키보드 단자, 마우스 단자, 스피커 단자 등이 따로 있어서 일일이 구분해서 끼워 넣어야 했고 놀고 있는 단자에 다른 기기를 접속하는 것도 불가능했다. 그 결과 컴퓨터의 확장성에도 제약이 있었다. 그래서 요즘은 키보드나 마우스, 프린터와 같은 대부분의 모든 컴퓨터 주변기기가 USB로 통일되어 가고 있는 분위기이다.


과거에는 단점이었으나 현재는 장점이 된 부분도 있다. 컨트롤러 구성이 단촐하지만, 메인 CPU의 의존률이 높다는 점이다. USB 보급 초기에는 '얘가 CPU 리소스 다 잡아먹는다, 


직렬 포트이기 때문에, 이론적으로 한 PC에서 127개까지 인식할 수가 있다고 한다.


badUSB라고 하는 USB 자체의 취약점이 2014년 7월 발표되었다. 본래 발표시에는 파장이 너무 클것 같아서 소스는 공개하지 않고 이런 공격이 가능하다는 것만 보였는데, 소스공개를 하지 않으면 제작사들의 반응이 뜨뜻미지근하게 돌아갈것을 우려하여 9월에 다른 단체에서 이 공격을 분석하여 소스까지 공개했다. 이 취약점을 이용하면 감지하는것도 거의 불가능하고 새로운 표준이 발표되어 취약점을 막는다고 해도 아예 하드웨어를 갈지 않는 한 패치도 불가능하다고 한다.



원리는 USB 기기의 펌웨어를 조작하여 본래의 기능과는 다른 장치(예를 들어 키보드나 마우스 등의 입력장치)로 일시적으로 인식시켜서 사용자가 의도하지 않은 행동을 하도록 신호를 보내는 것.[15] 이게 가능한 이유는 USB 단자의 작동 방식상 호스트는 연결된 장치가 깔라고 시키는 드라이버를 일단 깔아서 실행시켜보게 되어있다. 


USB 단자의 작동 방식상 호스트는 연결된 장치가 깔라고 시키는 드라이버를 일단 깔아서 실행시켜보게 되어있다. 



결국 2019년 까지도 이럴다할 차세대 표준이 나오지 않은 채 보안프로그램이 USB포트를 감시하다가 화이트리스트 방식으로 연결하는 정도만이 방어법으로 제시되고 있다. 



macOS 에서는 항상 데이터 캐싱을 사용하기 때문에 제거를 꼭 누르고 뽑아야 한다.



흔히 여러 가지 USB 장치들을 한 단자에 끼워서 사용할 수 있는 장치를 USB 허브라고 말한다. 보통은 컴퓨터나 노트북에 기본 제공되는 2개 정도면 충분하지만, 컴덕들은 플래시 메모리, 키보드, 마우스, 미니 선풍기(...), 미니 냉장고(...) 등 USB를 사용하는 장치들을 많이 가지고 있는 경우가 많으므로 기본 제공 USB 포트로는 수가 부족해 허브를 사용하게 된다. 블루투스/BLE는 전력 송신용으로는 적당하지 않기 때문에 용도가 제한된다.

다만 외부전원장치가 없는 외장하드의 경우에는 허브에 연결하면 전력부족으로 작동하지 않는 경우가 있으므로, 제조사에서는 대체로 허브 연결을 권하지 않거나 허브에 외부 전원을 연결할 것을 권장한다. 사실 외장하드 뿐만이 아니라 허브에 많은 USB 장치를 물려서 사용할 경우 전력부족 현상이 나타나면서 작동이 안 되는 경우가 많다. 이것은 USB 자체의 전력량은 적은데 허브로 물릴 경우 병렬 연결의 특성으로 인해 그 적은 전력량이 나눠져서 더 적어지기 때문이다. 외장하드 등의 많은 전력이 필요한데 허브에 연결해서 써야겠다면 위에서 언급한 것처럼 각 허브에 지원하는 것과 일치하는 외부 전력이 필요하다. 또한 간단하게 만들 수 있는 장치이다 보니 별의 별 신기한 모양으로 나오는 게 많다. 기차라든가, 가공 인물이라든가...

국내에 유통되는 USB 허브들의 절대 다수는 중국에서 만들어져 로고만 갈아치운 보따리 제품들이다. 그래서 생긴 건 똑같은데 회사 이름만 다른 물건들이 수두룩하다. 문제는 이런 제품들은 하자가 있는 경우가 대부분이라는 것. 특히 외장하드를 연결했다가 하드가 망가지거나 무선 마우스 등의 USB 수신기를 연결했는데 전파 간섭으로 인해 뚝뚝 끊기는 현상을 겪는 사례가 많다.

카드 리더기를 겸하는 경우도 있다. 이건 보통 허브에 비해 구하기 어려운 편. 이걸 쓸 때는 SD카드와 마이크로SD카드 슬롯을 제외한 다른 카드 슬롯은 개점휴업인 경우가 대부분이다.


자신의 기기 환경이 2.0이어도 3.0 지원 제품을 사용하면 기존 2.0 제품을 사용할 때보다는 다소 빨라진다. MLC 낸드를 사용한 USB 메모리인 경우에 2.0 제품은 쓰기 속도가 8~12 MB/s 정도 나온다면, 3.0 제품은 2.0 환경에서도 MLC는 쓰기 속도가 20~30 MB/s 정도 나온다. 그 반대(2.0 기기를 3.0 포트에 연결)는 어차피 2.0으로 작동하므로 상관이 없다.



완전 양방향 통신을 지원한다. 2.0까지는 반이중통신을 지원하나, 3.0은 데이터 채널이 2개이기 때문에 전 이중 통신을 할 수 있고, 하위 호환을 위하는 채널이 따로 있어서 총 3개의 채널이다. 2.0용과 3.0용 버스가 모두 있기 때문에 '듀얼 버스'라고 부른다. 이전까지의 단방향을 무전기에, 송수신을 동시에 할 수 있는 3.0을 전화기에 비유하면 이해가 쉽다.



USB 포트가 부족하면 USB 허브를 쓸 수 있지만 별도의 전기 어댑터가 달려 있지 않은 무전원 USB 허브를 이용하는 경우에 전기를 많이 잡아먹는 외장 하드 디스크 등을 꽂아 사용하면 전력 부족으로 제대로 작동되지 않는 경우가 있다. 따라서 외장 하드 디스크를 사용하면 유전원 USB 허브는 필수 확정. USB 2.0 인터페이스를 쓰더라도 전원 문제 때문에 유전원 USB 허브가 필요한 경우가 간혹 있다.





=> 허브에 몇개까지 기기를 꽂아도 전력이 안모자란지 NFR


덱스???
덱스머신을 가정해볼까?



연결하면 연결하겠습니까? 호스트에서 물어볼텐데
확인전까지는 데이터를 전송하지 않는다.
그러면 버퍼링해야하나? 요청자체가 없을테니 필요없나


USB 대용량 저장소 장치 유형은 연결되는 장치에서 사용되는 파일 시스템을 특정하고 있지는 않고, 대신 하드 디스크의 낮은 수준의 인터페이스처럼 데이터를 섹터 단위로 읽고 쓰는 수준의 단순한 인터페이스만을 규정한다. 따라서 운영 체제는 USB 드라이브를 하드 드라이브처럼 다룰 수 있고 그들이 운영 체제에서 제공하는 파일 시스템으로 포맷하는 것도 가능한다.



디지털 카메라나, MP3 플레이어와 같은 류의 장치들에서는 FAT 파일시스템이 장치 제조사에 의해 선호된다. 이동성이 좋고 상대적으로 편리하기 때문에 USB 플래시 드라이브, 디지털 카메라, 디지털 오디어 플레이어같은 임베디드 장치에서 가장 보편적인 파일 시스템은 마이크로소프트 사의 FAT이나 FAT32이다. 이런 장치에서 파일 시스템을 변경하면 장치가 동작하지 않을 수도 있으므로, 포맷 방식을 바꾸지 않는 것이 좋다.




입력장치의 유형을 알수있는가? 컨피그 과정?


USB는 장치의 기능을 식별하는 데 사용되는 클래스 코드 정보를 정의합니다.
그리고 명목상 그 기능을 기반으로 하는 장치 드라이버를 로드합니다.(장치로부터)
USB 시스템에는 호스트가 하나만 있습니다.
루트 허브는 호스트 내에 통합되어 하나 이상의 연결 지점을 제공합니다.


클래스코드?
HID
Mass Storage
Hub
Printer

5페이지에 표로 있음

인터페이스 역할인 입력인 경우 다른 연결까지 끌고 들어올 수 있다
=> 요구사항에 또 다른 허브의 연결에 대해서도 등록할 수 있어야 한다


수용가능한 클래스코드를 감지할 수 있어야 한다.
예를 들어 차량용 허브인데 프린터 연결하면 뭐함?



전력을 공급할 수 있어야 한다.
=> 전력 공급이 필요한 클래스의 경우에만(?) 아니면 클래스마다 다른 전력 공급



USB Framed data가 온다. 뭔가 패킷처럼 까고 열고 같은거 하지 않을까?
=> 요구사항 헤더 까서 알기?  클래스같은거




USB 디스크립터, 일시 중단, 재개 및 원격 깨우기와 같은 저전력 기능을 동적으로 변경하여 여러 장치 구성을 지원합니다. 다음 디바이스 클래스가 지원됩니다.

오디오 클래스 2.0(UAC2)
블루투스 호스트 컨트롤러 인터페이스(BTH HCI)
통신 장치 클래스(CDC)
장치 펌웨어 업데이트(DFU): DFU 모드(WIP) 및 Runtinme
휴먼 인터페이스 장치(HID): 일반(입력 및 출력), 키보드, 마우스, 게임패드 등 ...
대용량 스토리지 클래스(MSC): 여러 LUN 포함
악기 디지털 인터페이스(MIDI)
RNDIS, 이더넷 제어 모델(ECM), 네트워크 제어 모델(NCM)이 있는 네트워크
테스트 및 측정 클래스(USBTMC)
비디오 클래스 1.5(UVC): 작업 진행 중
일반 In & Out 끝점과 함께 공급업체별 클래스 지원. MS OS 2.0 호환 디스크립터와 함께 사용하여 INF 파일 없이 winUSB 드라이버를 로드할 수 있습니다.
공급업체별 클래스가 있는 WebUSB
특별한 요구 사항이 있는 경우 usbd_app_driver_get_cb()를 사용하여 스택을 수정하지 않고 고유한 클래스 드라이버를 작성할 수 있습니다. RPi 팀이 재설정 인터페이스 [raspberrypi/pico-sdk#197]( https://github.com/raspberrypi/pico-sdk/pull/197 )를 추가한 방법은 다음과 같습니다.


=> 유저가 클래스를 추가할 수 있는가?

수용가능한 클래스에 대해서 스테이터스 코드처럼 처리할 수 있는가?
http에서 영감을 얻었습니다 가능?
폴트 톨레랑스?


타이니에도 여러 클래스들이 정의되어 있다.
말그대로 자바 클래스가 될 수 있을 것 같다.



타이니에서 함수만 다 뽑아서 뭐하는건지만 정리해도 좀 될거같다



파이프엔 필터? 클래스 확인?


과제 12페이지 영어 부분에 요구사항이 많다.
isochronous 등시성 => 전송에 타이밍이 중요


요구 전력에 따라 공급하는게 맞는가?



멀티코어를 고려한 병렬 읽기 쓰기 가능?


데이터를 전송한다 <--익스텐드 --- 시그널 데이터를 전송한다.
 <--- 익스텐드 --- 데이터를 전송한다.




여러가지를 조합해서 유니크한 코드를 만들어내고 그거에 대해서 바로 접속 가능할지
vid pid


디바이스에 변하지 않는 내용이 있다면 캐싱이 가능할지?



디바이스의 필요한 전류량을 얻어와야하고 파워로부터 달라고 요청을 해야 한다.
enumeration 과정 중 기기측의 컴피규레이션 디스크립터의 bMaxPower에 기록된 전류량을 확인한다.
=> 하지만 실제로는 걍 100mA 혹은 500mA를 할당하는 경우가 많다.



USB 전원소스가 바뀌면 기기를 재열거해야한다.



데이터 전송속도에 따라 외부 LED의 점멸 속도가 다르게 보이게 하고 싶다
데이터 전송없이 충전중일때는 다른색으로 외부 LED가 점멸하면 좋겠다.

LED같은 디스플레이가 잇을지도

만약에 데이터의 끝을 알 수 있다면 전송 정도를 외부에 표시하고 싶다

예컨대 버퍼에 쌓인걸 위로 올려야한다
이런 경우 멀티코어로 나눠서 올릴수있나?


맥북의 경우 USB슬롯이 없어서(최신을 제외하고) 보통 서드파티의 허브를 사용하곤 한다. 벨킨꺼를 모델로 해볼까


USB 드라이버(USBD)는 기본 호스트를 제공합니다.
USB 장치에 대한 클라이언트용 인터페이스(USBDI). 인터페이스
HCD와 USBD 사이를 호스트라고 합니다.

=> 위아래 컴포넌트 나왔네 => BEST FRACTICE SSD 과제도 하드웨어 상 연결된 위아래를 외부 액터로 쓰더라

The interface
between the HCD and the USBD is known as the Host
Controller Driver Interface (HCDI). This interface is never
available directly to clients and thus is not defined by the
USB Specification. A particular HCDI is, however, defined
by each operating system that supports various Host
Controller implementations.
HCD와 USBD 사이의 인터페이스는 호스트로 알려져 있습니다.
컨트롤러 드라이버 인터페이스(HCDI). 이 인터페이스는 클라이언트에서 직접 사용할 수 없으므로 USB 사양에서 정의하지 않습니다. 그러나 특정 HCDI는 다양한 호스트 컨트롤러 구현을 지원하는 각 운영 체제에 의해 정의됩니다.

882 / 5,000
번역 결과
USBD는 특정 파이프를 통해 데이터를 전송하라는 요청으로 구성된 I/O 요청 패킷(IRP) 형식의 데이터 전송 메커니즘을 제공합니다.
=> 프로토콜에서 그러하듯 논리적인 파이프 개념 =>  아랫단의 피지컬 연결은 모른다
=> 그렇다면 피지컬 연결과 논리적 연결의 매핑이 필요하겠군

=> 같은 피지컬 연결에 시그널연결과 데이터 연결 이렇게 논리적 매핑이 다를 수 있음

그렇다면 또 레이어드가 되어야 하나
레이어드라면 하위의 앱스트렉트 클래스를 참조하는 것 활용하자
시그널 연결은 또 클래스별로 갈라질 수 있나
이름은 디폴트 파이프이다.
usb wire는 피지컬 채널
default pipe는 논리적 채널
=> 이름을 그대로 써야하나 => 상속?


일부 운영 체제에서는 장치 드라이버에 구성 및 로드 메커니즘을 제공하는 추가 비 USB 시스템 소프트웨어를 사용할 수 있습니다. 이러한 운영 체제에서 장치 드라이버는 USBDI 메커니즘에 직접 액세스하는 대신 제공된 인터페이스를 사용해야 합니다.

=> 바이패스하는 플로우도 제공해야하나
The USB Driver (USBD) provides the basic host
interface (USBDI) for clients to USB devices.
=> 그게 아닌가..?




파이프에 대역폭이랑 이런거 있을텐데 이거 Pool 개념으로 접근해야하나? => 일단 도메인모델에서는 풀개념 이런거 안된다



클라이언트 계층은 USB 장치와 직접 상호 작용하는 모든 소프트웨어 엔터티를 설명합니다. 각 장치가 시스템에 연결되면 이러한 클라이언트는 주변 하드웨어와 직접 상호 작용할 수 있습니다. USB의 공유 특성은 클라이언트와 해당 장치 사이에 USB 시스템 소프트웨어를 배치합니다. 즉, 클라이언트는 장치의 하드웨어에 직접 액세스할 수 없습니다.
전반적으로 호스트 계층은 다음 기능을 제공합니다.
• USB 장치의 부착 및 제거 감지
• 호스트와 USB 장치 간의 USB 표준 제어 흐름 관리
• 호스트와 USB 장치 간의 데이터 흐름 관리
• 현황 및 활동 통계 수집
• 제한된 양의 전원 제공을 포함하여 호스트 컨트롤러와 USB 장치 간의 전기 인터페이스 제어

도메인 모델(개념적 구조)을 정립한다.
=> 너무 구조가 반영되면 안된다.
이런 부분은 변경용이성을 위해 앱스트랙션이 되어야해 캐시가 있어야해 이런건 구조가 반영된것이다. 이런건 의존성이 문제야라던지. 유의
네고시에이터 도메인은 있어야겠군

네고시에이터
스트림 팩토리(?) => 요거 너무 구현? 도메인모델에는 안될듯
스트림도 도메인모델일수있을거같은데


끝점은 호스트와 장치 간의 통신 흐름의 종단인 USB 장치의 고유하게 식별 가능한 부분입니다. 각 USB 논리 장치는 독립적인 끝점 모음으로 구성됩니다.
끝점에는 끝점과 클라이언트 소프트웨어 간에 필요한 전송 서비스 유형을 결정하는 특성이 있습니다.
끝점은 다음과 같이 자신을 설명합니다.
• 버스 액세스 빈도/대기 시간 요구 사항
• 대역폭 요구 사항
• 엔드포인트 번호
• 오류 처리 동작 요구 사항
• 엔드포인트가 보내거나 받을 수 있는 최대 패킷 크기
• 엔드포인트의 전송 유형(자세한 내용은 섹션 5.4 참조)
• 엔드포인트와 호스트 간에 데이터가 전송되는 방향
끝점 번호가 0인 끝점 이외의 끝점은 구성되기 전에 알 수 없는 상태에 있으며 구성되기 전에 호스트에서 액세스할 수 없습니다.

요구사항이라는거보니 컨텐츠 네고시에이션 가능할듯



무엇이 asr인지를 꼭 정리해야 한다. 물어볼거같으니까 




특정 운영체제에 속한 디바이스 드라이버를 만들것인지?
클래스 드라이버까지 포함하는 임베디드 드라이버일수도 있다.

어떤 하드웨어인지도 가정한다.
ochi xhci를 제공하는 하드웨어다 이렇게 가정가능 => 변경용이성은 고려해야겠지

어플리케이션(클라이언트)에서 쉽게 개발하기위해 기능을 많이 가지는것도 좋다.
(어플리케이션단에서도 파이프가 있는데 제공해준다던지)



usb슬롯이 있는 나스서버를 가정하고 웹에서 파일 브라우징이 가능한 시스템? 오반가

어플리케이션에서 여러 usb를 사용한다던가 그런 시나리오도 있을 수 잇ㅇ므
=> 매핑정보를 저장해야하나?



유저디파인드 클래스 가능할듯


usb 4.0으로 바뀐다면 쉽게 바뀔 수 있나? 앱스트랙트가 답이지!


그림보니 하드웨어 버스랑 ipc로 통신한다 이런게 있네(세로 화살표)



품질속성(QA)은 만족할수록 더 좋은것
비기능요구사항은 허용치가 있어서 제약이 있는것이다.

메일보낼때 싱글도 포함해서 보내면 확인가능할듯
파일압축하지말것
파일크기는 10메가 이하로



USB 파이프는 장치의 끝점과 호스트의 소프트웨어 간의 연결입니다. 파이프는 메모리 버퍼와 장치의 끝점을 통해 호스트의 소프트웨어 간에 데이터를 이동하는 기능을 나타냅니다. 두 개의 상호 배타적인 파이프가 있습니다.
통신 모드:
• 스트림: 파이프를 통해 이동하는 데이터에는 USB 정의 구조가 없습니다.
• 메시지: 파이프를 통해 이동하는 데이터에는 일부 USB 정의 구조가 있습니다.<시그널링 정보같은 개념인듯>
USB는 파이프를 통해 전달하는 데이터의 내용을 해석하지 않습니다. 메시지 파이프에서 USB 정의에 따라 데이터를 구성해야 하지만 데이터의 내용은 USB에서 해석되지 않습니다.
또한 파이프에는 다음과 같은 관련 항목이 있습니다.
• USB 버스 액세스 및 대역폭 사용에 대한 주장.
• 전송 유형.
• 방향성 및 최대 데이터 페이로드 크기와 같은 연결된 끝점의 특성. 데이터 페이로드는
버스 트랜잭션 내에서 데이터 패킷의 데이터 필드에 전달됩니다(8장에서 정의됨).
끝점 번호가 0인 두 끝점으로 구성된 파이프를 기본 제어 파이프라고 합니다. USB 시스템 소프트웨어는 기본 제어 파이프의 "소유권"을 유지하고 다른 클라이언트 소프트웨어의 파이프 사용을 중재합니다. USB 시스템 소프트웨어는 여러 요청이 동시에 메시지 파이프로 전송되지 않도록 합니다.

USB 시스템 소프트웨어는 여러 요청이 동시에 메시지 파이프로 전송되지 않도록 합니다.
=> 유념

USB는 네 가지 전송 유형을 정의합니다.
• 제어 전송: 일반적으로 명령/상태 작업에 사용되는 버스트, 비주기적, 호스트 소프트웨어 시작 요청/응답 통신입니다.

• Isochronous Transfers: 일반적으로 시간 관련 정보에 사용되는 호스트와 장치 간의 주기적이고 지속적인 통신입니다.
이 전송 유형은 데이터에 캡슐화된 시간 개념도 보존합니다. 그러나 이것이 그러한 데이터의 전달 요구가 항상 시간 결정적이라는 것을 의미하지는 않습니다.
<싱크채널같은 느낌>

• 인터럽트 전송: 저주파, 제한된 대기 시간 통신.
• 대량 전송: 일반적으로 사용 가능한 모든 대역폭을 사용할 수 있고 대역폭을 사용할 수 있을 때까지 지연될 수 있는 데이터에 사용되는 비주기적인 대규모 패킷 버스트 통신입니다.

=> 이것들 채널이라는 개념과 그 구현체로 볼 수 있을 것 4같다.





USB 장치의 기능을 사용하려면 먼저 장치를 구성해야 합니다. 호스트는 USB 장치 구성을 담당합니다.
전력을 절약하기 위해 USB 장치는 지정된 기간 동안 버스 트래픽이 관찰되지 않으면 자동으로 일시 중단 상태로 들어갑니다. 일시 중단되면 USB 장치는 주소 및 구성을 포함한 모든 내부 상태를 유지합니다.

=> 스테이트 개념도 있다.
=> ConnectedDeviceEntity라는 개념이 있어서 거기에 업데이트





9.1.2 버스 열거
USB 장치가 USB에 연결되거나 제거될 때 호스트는 버스 열거로 알려진 프로세스를 사용하여 식별하고
필요한 장치 상태 변경을 관리합니다. USB 장치가 전원이 공급되는 포트에 연결되면 다음 작업이 수행됩니다.
1. USB 장치가 연결된 허브는 상태 변경 파이프에 대한 응답을 통해 호스트에 이벤트를 알립니다.
이 시점에서 USB 장치는 전원이 공급된 상태이고 연결된 포트는 비활성화됩니다   (그렇다면 필요한 전류는 이미 전달된 상태인듯 아니네 밑에 보니까 최소전력만 보내는듯?).
2. 호스트는 허브를 쿼리하여 변경 사항의 정확한 특성을 확인합니다.
3. 이제 호스트가 새 장치가 연결된 포트를 알고 있으므로 호스트는 다음을 허용하기 위해 최소 100ms 동안 기다립니다.
삽입 과정이 완료되고 장치의 전원이 안정됩니다. 그런 다음 호스트는 포트 활성화 및 재설정을 실행합니다.
해당 포트로 명령합니다.
4. 허브는 해당 포트에 필요한 재설정 처리를 수행합니다. 리셋 신호가 해제되면 포트가 활성화된 것입니다.
USB 장치는 이제 기본 상태이며 VBUS에서 최대 100mA를 끌어올 수 있습니다. 모든 레지스터와 상태는
재설정하고 기본 주소에 응답합니다.
5. 호스트는 USB 장치에 고유한 주소를 할당하여 장치를 주소 상태로 이동합니다.          (고유한 주소를 할당한다...)
6. USB 장치가 고유한 주소를 받기 전에 기본 주소를 통해 기본 제어 파이프에 계속 액세스할 수 있습니다.            (이 항목에 세부동작에 대한 힌트가 많이 있네)
호스트는 이 USB 장치의 기본 파이프가 사용할 수 있는 실제 최대 데이터 페이로드 크기를 결정하기 위해 장치 설명자를 읽습니다.           (최대 데이터 페이로드 => 이것도 네고절차가 있지않을까)
7. 호스트는 각 구성을 0에서 n-1까지 읽어 장치에서 구성 정보를 읽습니다. 여기서 n은
구성. 이 프로세스를 완료하는 데 몇 밀리초가 걸릴 수 있습니다.                                             (요구사항에 들어갈만한 숫자인듯)
8. 구성 정보와 USB 장치가 사용되는 방식을 기반으로 호스트는 장치에 구성 값을 할당합니다.
이제 장치는 구성됨 상태이고 이 구성의 모든 끝점은 설명된 특성을 사용합니다.
USB 장치는 이제 선택한 구성에 대한 설명자에 설명된 VBUS 전력량을 끌어올 수 있습니다.                 (VBUS라는데가 전력을 결정짓는 모듈인듯)
장치의 관점에서 볼 때 이제 사용할 준비가 되었습니다.
USB 장치가 제거되면 허브는 다시 호스트에 알림을 보냅니다. 장치를 분리하면 장치가 있던 포트가 비활성화됩니다.
첨부했습니다. 분리 알림을 받으면 호스트는 로컬 토폴로지 정보를 업데이트합니다.



ACTOR
LED, VBUS, DEVICES(...), USER(?), APP, HAL


9.2.3 구성
USB 장치는 기능을 사용하기 전에 구성해야 합니다. 호스트는 USB 장치 구성을 담당합니다. 호스트는 일반적으로 USB 장치의 구성 정보를 요청하여 장치의 기능을 결정합니다.
단일 구성 내에서 장치는 여러 인터페이스를 지원할 수 있습니다. 인터페이스는 장치의 단일 기능 또는 기능을 호스트에 제공하는 관련 엔드포인트 세트입니다. 이 관련된 끝점 세트와 통신하는 데 사용되는 프로토콜과 인터페이스 내 각 끝점의 목적은 장치 클래스 또는 공급업체별 정의의 일부로 지정될 수 있습니다. 또한 구성 내의 인터페이스에는 연결된 끝점의 수 또는 특성을 재정의하는 대체 설정이 있을 수 있습니다.
USB 장치의 관련 그룹을 관리할 수 있는 적응형 장치 드라이버를 지원하기 위해 장치 및 인터페이스 설명자는 클래스, 하위 클래스 및 프로토콜 필드를 포함합니다. 이 필드는 USB 장치에서 제공하는 기능과 장치의 기능과 통신하는 데 사용되는 프로토콜을 식별하는 데 사용됩니다.




타이니유에스비에 ADDR0라던지 0이 붙은게 많은데 이게 엔드포인트0을 의미하는건가?



디바이스의 디스크립션도 도메인의 어트리뷰트가 될거같은데



문서에 코드 설명한 플로우만 봐도 뭔가 모듈화할만한게 보인다.

센드때는 hcd_setup_send()하는데 요게 hal 부분일듯






음...유즈케이스가 뭐가 있지?

유저가 usb 디바이스를 허브에 꽂는다.
alt => 허용하지않는 클래스(가능한 많은 클래스라해도 안되는게 있을수있고 그렇다면 시나리옥 ㅣ있어야지)


유저가 디바이스를 허브에서 뽑는다.


충분한 전력이 공급되어야한다 => nfr

허브는 연결된 디바이스를 충전한다. => 충전이 필요한 기기여야한다. 자체 전원이 없어야한다(?)



디바이스로 데이터를 전송한다.

클라이언트로 데이터를 전송한다.


LED를 점멸한다. --extend--> 데이터를 전송
---extend--> 충전



디스크립션을 받아서 설정할 수 있어야 한다. =>FR


한번 연결된 장치는 더 빠르게 연결할 수 있어야 한다 => FR


데이터 전송 속도에 따라 LED가 점멸할 수 있어야 한다.

충전 상태를 LED 주황색으로 확인할 수 있어야 한다.
(배터리 잔량도 받을 수 있나?)

여러개의 디바이스가 연결되어도 각각의 연결이 독립성이 보장되어야 한다. ->NFR


벨킨같은거 보면 100w충전, 10gpbs 이런거 지원한다 이런식으로 나와있음 활용
=> 하드웨어 구성을 허브에 별도 전원이 있는걸로 설정하자



























4.5 견고성
등시성 및 하드웨어 버퍼 관리를 보장하기 위한 스트리밍 데이터의 흐름 제어
사이의 불리한 상호 작용으로부터 독립성을 보장하기 위한 데이터 및 제어 파이프 구성

4.5.1 오류 감지
프로토콜에는 각 패킷에 CRC가 포함된다 => 근데 이건 파이 레벨일듯. 허브단계에서의 오류 검증은? => 퍼포몬스랑 상충될텐데? AD

4.5.2 에러 핸들링
A USB Host Controller will try a transmission that encounters errors up to
three times before informing the client software of the failure. 
=> 3번까지


4.6 시스템 구성
장치 연결
버스 열거 => 컨피그 단계
장치 해제


The USB architecture comprehends four basic types of data transfers:
• Control Transfers: Used to configure a device at attach time and can be used for other device-specific
purposes, including control of other pipes on the device.
• Bulk Data Transfers: Generated or consumed in relatively large and bursty quantities and have wide
dynamic latitude in transmission constraints.
• Interrupt Data Transfers: Used for timely but reliable delivery of data, for example, characters or
coordinates with human-perceptible echo or feedback response characteristics.
• Isochronous Data Transfers: Occupy a prenegotiated amount of USB bandwidth with a prenegotiated
delivery latency. (Also called streaming real time transfers). => 네고 개념 나왔네 => 등시성은 화질이 깨져도 일정한 시간으로 전송하나보다
=> 4.7부터 세부설명 있음 중요하니 나중에 또 보자


제어전송 => 별도 채널은 아니고 처음 연결 단계에서의 시간에서 데이터 전송을 말하는듯


USB 장치는 다음과 같이 가정합니다.더 많은 대역폭이 필요한 경우 더 큰 버퍼를 제공할 수 있습니다. USB 아키텍처의 목표는버퍼링으로 인한 하드웨어 지연이 몇 밀리초 이내로 제한되도록 합니다.


 USB devices are required to carry information for selfidentification and generic configuration. They are also required at all times to display behavior consistent
with defined USB device states.




오잉 이미 기능 나왔네 이거라고 함
USB 시스템 소프트웨어와 장치 소프트웨어 간의 상호 작용에는 5가지 영역이 있습니다.
•장치 열거 및 구성
•등시성 데이터 전송
•비동기식 데이터 전송
•전원 관리
•장치 및 버스 관리 정보


외부 액터가 사람이 아니라 USB 디바이스라면?
=> 그렇다면 자극은 뭐지? 사람이 넣으면 자극인데




USB 물리적 장치: USB 케이블 끝에 있는 하드웨어로 일부 유용한 기능을 수행합니다.사용자 기능
.•클라이언트 소프트웨어: USB 장치에 해당하는 호스트에서 실행되는 소프트웨어입니다. 이 클라이언트소프트웨어는 일반적으로 운영 체제와 함께 제공되거나 USB 장치와 함께 제공됩니다
.•USB 시스템 소프트웨어: 특정 운영 체제에서 USB를 지원하는 소프트웨어. USB시스템 소프트웨어는 일반적으로 특정 USB와 별도로 운영 체제와 함께 제공됩니다.장치 또는 클라이언트 소프트웨어
.•USB 호스트 컨트롤러(호스트 측 버스 인터페이스): USB 장치를 허용하는 하드웨어 및 소프트웨어호스트에 연결됩니다




호스트가 패킷을 볼수없는게 맞는거겠지
=> 요구사항에 들어가야하나





허브가 제거되면 연결된 모든 디바이스가 사라진다.
=> 유즈케이스에 허브 자체에 대한 연결은?



QAS를 정할때 핵심적인 기능에 대한 요구사항을 적는게 좋다
그리고 주식장 피크타임에는 얼마 요구 이런식으로나누넌것도 좋다




usb를 확 뽑을때를 대비해서 캐시에 데이터를 뒀다가 마무리
=> 안정성?


QAS => 버튼을 눌렀을때 반응속도 모드 전환속도 등이 로봇청소기를 구입을 결정할만한 품질요ㅕ소가 아님. 말그대로 구매의사를 좌우할수있는 요소에 해당됨
청소속도나 소음이나 배터리같은거 아닐까
=> 기능이 들어가지 않도록 주의 => 새로운 경로로 변경하여야ㅐ한다. 등등
=> 형용사 사용 안됨 거리를 정상적으로 인지하여, 일반가정집에서, 전체 청소 영역에서(영역넓이로 바꿔야함)

맥스모드에서 소음이 100DB을넘지않아야한다 뭐 이런식으로 해야함





클라이언트 소프트웨어는 파이프를 사용하여 인터페이스를 관리합니다.번들(엔드포인트 세트와 연결됨). 클라이언트 소프트웨어는 USB를 통해 데이터를 이동하도록 요청합니다.호스트의 버퍼와 USB 장치의 끝점 사이. 호스트 컨트롤러(또는 USB 장치,전송 방향에 따라) 데이터를 패킷화하여 USB를 통해 이동합니다. 호스트 컨트롤러도버스 액세스가 USB를 통해 데이터 패킷을 이동하는 데 사용되는 경우를 조정합니다.


Figure 5-10 그림 참고

엔드포인트는 통신 흐름의 종점인 USB 장치의 고유하게 식별 가능한 부분입니다


각 논리 장치에는 장치 연결 시 시스템에서 할당한 고유한 주소가 있습니다.장치의 각 끝점에는 끝점이라고 하는 고유한 장치 결정 식별자가 디자인 타임에 제공됩니다.숫자. 각 끝점에는 장치가 결정한 데이터 흐름 방향이 있습니다
장치의 조합주소, 끝점 번호 및 방향을 통해 각 끝점을 고유하게 참조할 수 있습니다



끝점은 다음과 같이 자신을 설명합니다.•버스 액세스 빈도/대기 시간 요구 사항•대역폭 요구 사항•엔드포인트 번호•오류 처리 동작 요구 사항•엔드포인트가 보내거나 받을 수 있는 최대 패킷 크기•엔드포인트의 전송 유형(자세한 내용은 섹션 5.4 참조)•엔드포인트와 호스트 간에 데이터가 전송되는 방향
Endpoints other than those with endpoint number zero are in an unknown state before being configured and
may not be accessed by the host before being configured.



All USB devices are required to implement a default control method that uses both the input and output
endpoints with endpoint number zero. The USB System Software uses this default control method to
initialize and generically manipulate the logical device (e.g., to configure the logical device) as the Default
Control Pipe (see Section 5.3.2). The Default Control Pipe provides access to the device’s configuration
information and allows generic USB status and control access. The Default Control Pipe supports control
transfers as defined in Section 5.5. The endpoints with endpoint number zero are always accessible once a
device is attached, powered, and has received a bus reset.


5.3.2 파이프USB 파이프는 장치의 끝점과 호스트의 소프트웨어 간의 연결입니다. 파이프는 다음을 나타냅니다.메모리 버퍼와 장치의 끝점을 통해 호스트의 소프트웨어 간에 데이터를 이동하는 기능. 거기두 가지 상호 배타적인 파이프 통신 모드는 다음과 같습니다.•스트림: 파이프를 통해 이동하는 데이터에는 USB 정의 구조가 없습니다.•메시지: 파이프를 통해 이동하는 데이터에는 USB 정의 구조가 있습니다.USB는 파이프를 통해 전달하는 데이터의 내용을 해석하지 않습니다. 비록 메시지 파이프USB 정의에 따라 데이터를 구성해야 하며 데이터 내용은 USB로 해석되지 않습니다.USB.또한 파이프에는 다음과 같은 관련 항목이 있습니다.•USB 버스 액세스 및 대역폭 사용에 대한 주장.•전송 유형입니다.•방향성 및 최대 데이터 페이로드 크기와 같은 연결된 끝점의 특성입니다. 그만큼데이터 페이로드는 버스 트랜잭션 내에서 데이터 패킷의 데이터 필드에 전달되는 데이터입니다(8장에 정의됨).끝점 번호가 0인 두 끝점으로 구성된 파이프를 기본 제어 파이프라고 합니다.이 파이프는 장치에 전원이 공급되고 버스 재설정을 수신하면 항상 사용할 수 있습니다. 다른 파이프가 들어옵니다.USB 장치가 구성될 때 존재합니다. 기본 제어 파이프는 USB 시스템 소프트웨어에서 사용됩니다.장치 식별 및 구성 요구 사항을 결정하고 장치를 구성합니다. 기본값Control Pipe는 장치가 구성된 후 장치별 소프트웨어에서도 사용할 수 있습\\\




USB  시스템 소프트웨어는 기본 제어 파이프의 "소유권"을 유지하고 다른 클라이언트의 파이프 사용을 중재합니다.소프트웨어.소프트웨어 클라이언트는 일반적으로 I/O 요청 패킷(IRP)을 통해 파이프로 데이터 전송을 요청한 다음 다음 중 하나를 수행합니다.완료되면 기다리거나 알림을 받습니다. IRP에 대한 세부 정보는 운영 체제에 정의되어 있습니다.구체적인 방법. 이 사양에서는 소프트웨어에서 식별 가능한 요청을 단순히 참조하기 위해 이 용어를 사용합니다.클라이언트는 자신(호스트에서)과 장치의 끝점 사이에서 적절한 방향으로 데이터를 이동합니다. ㅏ소프트웨어 클라이언트는 원하는 경우 파이프가 미해결 IRP를 모두 반환하도록 할 수 있습니다. 소프트웨어 클라이언트가 알림을 받습니다.IRP와 관련된 버스 트랜잭션이 성공적으로 완료되었을 때 IRP가 완료되었음을 나타냅니다.또는 오류로 인해.파이프에 대해 보류 중이거나 진행 중인 IRP가 없으면 파이프가 유휴 상태이고 호스트 컨트롤러는 아무 작업도 수행하지 않습니다.파이프에 대한 조치; 즉, 그러한 파이프의 끝점은 다음으로 향하는 버스 트랜잭션을 볼 수 없습니다.그것. 파이프에 대한 버스 활동이 있는 유일한 시간은 해당 파이프에 대해 IRP가 보류 중인 경우입니다.비등시성 파이프가 호스트에 STALL을 보내도록 하는 조건이 발생하는 경우(참조8장) 또는 IRP의 패킷에서 3개의 버스 오류가 발생하면 IRP가 중단/중단됩니다.미해결 IRP도 폐기되며 소프트웨어 클라이언트가 복구될 때까지 더 이상의 IRP는 허용되지 않습니다.조건(구현에 따라 다름)을 통해 중지 또는 오류 조건을 확인합니다.USBD 호출. 적절한 상태는 오류 대 정지에 대한 특정 IRP 결과를 소프트웨어 클라이언트에 알려줍니다.(제10장 참조). 등시성 파이프 동작은 섹션 5.6에 설명되어 있습니다.IRP는 버스를 통해 클라이언트 데이터를 이동하기 위해 여러 데이터 페이로드가 필요할 수 있습니다. 이러한 데이터 페이로드다중 데이터 페이로드 IRP는 마지막 데이터 페이로드까지 최대 패킷 크기가 될 것으로 예상됩니다.전체 IRP의 나머지를 포함합니다. 자세한 내용은 각 전송 유형에 대한 설명을 참조하세요. 을위한이러한 IRP, 입력에서 완전히 채우지 않는 짧은 패킷(즉, 최대 크기의 데이터 페이로드 미만)IRP 데이터 버퍼는 클라이언트의 기대에 따라 두 가지 의미 중 하나를 가질 수 있습니다.•클라이언트는 IRP에서 다양한 크기의 데이터를 기대할 수 있습니다. 이 경우 전송되지 않는 짧은 패킷IRP 데이터 버퍼 채우기는 "데이터 단위 끝"을 나타내는 대역 내 구분 기호로 간단히 사용할 수 있습니다. 그만큼IRP는 오류 없이 폐기되어야 하며 호스트 컨트롤러는 다음 IRP로 진행해야 합니다.•클라이언트는 특정 크기의 데이터를 기대할 수 있습니다. 이 경우 IRP를 채우지 않는 짧은 패킷데이터 버퍼는 오류를 나타냅니다. IRP는 폐기되어야 하고, 파이프는 정지되어야 하며,파이프와 관련된 보류 중인 IRP도 폐기되어야 합니다.호스트 컨트롤러는 두 가지 경우에 다르게 동작해야 하고 어떤 것이 그 자체로 알 수 없기 때문에주어진 IRP에 대해 행동하는 방법; 클라이언트가 원하는 행동을 IRP별로 표시하는 것이 가능합니다.끝점은 NAK로 응답하여 호스트에 자신이 사용 중임을 알릴 수 있습니다. NAK는 퇴직금으로 사용되지 않습니다.IRP를 소프트웨어 클라이언트에 반환하기 위한 조건입니다. NAK는 수에 관계없이 발생할 수 있습니다.주어진 IRP의 처리. 트랜잭션에 대한 NAK 응답은 오류를 구성하지 않으며 계산되지 않습니다.위에서 설명한 세 가지 오류 중 하나입니다


스트림 파이프
스트림 파이프는 USB가 필요한 구조 없이 버스 트랜잭션의 데이터 패킷 부분에서 데이터를 전달합니다.데이터 내용. 데이터는 스트림 파이프의 한 쪽 끝에서 들어오고 같은 순서로 다른 쪽 끝으로 흐릅니다. 개울파이프는 통신 흐름에서 항상 단방향입니다.스트림 파이프를 통해 흐르는 데이터는 USB가 단일 클라이언트라고 믿는 것과 상호 작용할 것으로 예상됩니다.USB 시스템 소프트웨어는 여러 클라이언트 간에 동기화를 제공하는 데 필요하지 않습니다.동일한 스트림 파이프를 사용합니다. 스트림 파이프에 제공된 데이터는 파이프를 통해 순차적으로 이동됩니다.선입금, 선입금.장치에 대한 스트림 파이프는 적절한 방향(즉,프로토콜 계층에 의해 정의된 IN 또는 OUT 토큰에 해당). 에 대한 장치 끝점 번호반대 방향은 장치에 대한 일부 다른 스트림 파이프에 사용될 수 있습니다


5.3.2.2 메시지 파이프메시지 파이프는 스트림 파이프와 다른 방식으로 끝점과 상호 작용합니다. 먼저 요청이 다음으로 전송됩니다.호스트에서 USB 장치. 이 요청에 이어 적절한 방향으로 데이터가 전송됩니다.마지막으로 잠시 후 상태 단계가 이어집니다. 요청/데이터/상태를 수용하기 위해패러다임, 메시지 파이프는 명령을 허용하는 통신 흐름에 구조를 부과합니다.확실하게 식별하고 전달합니다. 메시지 파이프는 양방향으로 통신 흐름을 허용합니다.통신 흐름이 주로 단방향일 수 있지만. 기본 제어 파이프는 항상메시지 파이프.USB 시스템 소프트웨어는 여러 요청이 동시에 메시지 파이프로 전송되지 않도록 합니다. ㅏ장치는 메시지 파이프당 한 번에 하나의 메시지 요청만 서비스하는 데 필요합니다. 여러 소프트웨어호스트의 클라이언트는 기본 제어 파이프를 통해 요청할 수 있지만 첫 번째로 장치로 전송됩니다.안으로, 먼저 나오는 순서. 장치는 다음을 기반으로 데이터 및 상태 단계에서 정보의 흐름을 제어할 수 있습니다.호스트 트랜잭션에 응답하는 기능(자세한 내용은 8장 참조).메시지 파이프는 일반적으로 현재 메시지가 수신될 때까지 호스트에서 다음 메시지를 보내지 않습니다.장치에서 처리가 완료되었습니다. 그러나 다음과 같은 오류 조건이 있습니다.호스트가 전송을 중단할 수 있고 메시지 파이프가 새 메시지 전송을 조기에 보낼 수 있습니다.(장치의 관점에서). 메시지 파이프를 조작하는 소프트웨어의 관점에서 볼 때 오류IRP의 일부에서 현재 IRP와 대기 중인 모든 IRP를 폐기합니다. 요청한 소프트웨어 클라이언트IRP는 적절한 오류 표시와 함께 IRP 완료 알림을 받습니다.장치에 대한 메시지 파이프에는 양방향(IN 및 OUT토큰). USB는 메시지 파이프가 각각에 대해 다른 끝점 번호와 연결되는 것을 허용하지 않습니다.방향.메시지 파이프는 섹션 5.5에 설명된 제어 전송 유형을 지원합니다



.3.3 프레임과 마이크로프레임USB는 전체/저속 버스에서 프레임이라고 하는 1밀리초 시간 기반과 125μs 시간 기반 을 설정합니다.고속 버스에서 마이크로프레임이라고 합니다. (마이크로)프레임은 여러 트랜잭션을 포함할 수 있습니다. 각 전송유형은 엔드포인트의 (마이크로)프레임 내에서 허용되는 트랜잭션을 정의합니다. 등시성 및 인터럽트끝점에는 N(마이크로)프레임마다 버스에 대한 기회가 주어집니다. N 값 및 기타 세부 정보등시성 및 인터럽트 전송은 섹션 5.6 및 5.7에 설명되어 있습니다



5.4 전송 유형USB는 소프트웨어 클라이언트와 연결된 메모리 버퍼 사이의 파이프를 통해 데이터를 전송합니다.호스트 및 USB 장치의 끝점. 메시지 파이프에 의해 전송되는 데이터는 USB 정의그러나 USB는 USB 정의 내에서 장치별 구조화된 데이터를 전송할 수 있습니다.메시지 데이터 페이로드. USB는 또한 버스를 통해 이동된 데이터가 모든 파이프에 대해 패킷화됨을 정의합니다.(스트림 또는 메시지), 그러나 궁극적으로 데이터에서 전송되는 데이터의 형식화 및 해석버스 트랜잭션의 페이로드는 파이프를 사용하는 클라이언트 소프트웨어 및 기능의 책임입니다.그러나 USB는 서비스에 보다 밀접하게 일치하도록 최적화된 다양한 전송 유형을 제공합니다.파이프를 사용하는 클라이언트 소프트웨어 및 기능의 요구 사항. IRP는 하나 이상의 버스 트랜잭션을 사용합니다.소프트웨어 클라이언트와 해당 기능 간에 정보를 이동합니다.각 전송 유형은 다음을 포함하여 통신 흐름의 다양한 특성을 결정합니다.•USB에 의해 부과된 데이터 형식•커뮤니케이션 흐름의 방향•패킷 크기 제약
버스 접근 제약•대기 시간 제약•필수 데이터 시퀀스•오류 처리USB 장치의 설계자는 장치의 끝점에 대한 기능을 선택합니다. 파이프일 때끝점에 대해 설정되면 대부분의 파이프 전달 특성이 결정되고 고정된 상태로 유지됩니다.파이프의 수명. 변경할 수 있는 전송 특성은 각 전송 유형에 대해 설명되어 있습니다.USB는 네 가지 전송 유형을 정의합니다.•제어 전송: 버스트, 비주기적, 호스트 소프트웨어 시작 요청/응답 통신,일반적으로 명령/상태 작업에 사용됩니다.•Isochronous Transfers: 일반적으로 사용되는 호스트와 장치 간의 주기적이고 지속적인 통신시간 관련 정보. 이 전송 유형은 또한데이터. 그러나 이것이 그러한 데이터의 전달 요구가 항상 시간 결정적이라는 것을 의미하지는 않습니다.•인터럽트 전송: 저주파, 제한된 대기 시간 통신.•대량 전송: 일반적으로 다음을 사용할 수 있는 데이터에 사용되는 비주기적인 대용량 패킷 버스트 통신사용 가능한 모든 대역폭과 대역폭을 사용할 수 있을 때까지 지연될 수도 있습니다.각 전송 유형은 다음 네 가지 주요 섹션에 자세히 설명되어 있습니다. 모든 IRP에 대한 데이터는섹션 8.3.4에 설명된 대로 데이터 패킷의 데이터 필드에 의해 전달됩니다. 8장에서는 또한각 특정 전송 유형의 사용에 의해 영향을 받는 프로토콜


Control Transfers
USB 시스템은 호스트와 호스트 간의 제어 전송을 지원하기 위해 "최선의 노력"을 기울일 것입니다.장치. 기능 및 해당 클라이언트 소프트웨어는 특정 버스 액세스 주파수 또는 대역폭을 요청할 수 없습니다.제어 전송. USB 시스템 소프트웨어는 장치가 사용할 수 있는 버스 액세스 및 대역폭을 제한할 수 있습니다.통제 이전에 대한 욕구. 이러한 제한 사항은 섹션 5.5.3 및 섹션 5.5.4에 정의되어 있습니
제어 전송은 메시지 파이프를 통해 양방향 통신 흐름을 지원한다. 제어파이프가 "구성되면" 입출력 엔드포인트를 모두 사용ㅎ나다.






5.5.3 제어 전송 패킷 크기 제약제어 전송을 위한 끝점은 끝점이 허용할 수 있는 최대 데이터 페이로드 크기를 지정합니다.또는 버스로 전송합니다. 최대 속도 장치에 허용되는 최대 제어 전송 데이터 페이로드 크기는 다음과 같습니다.8, 16, 32 또는 64바이트; 고속 장치의 경우 64바이트, 저속 장치의 경우 8바이트입니다. 이것최대값은 설정 후 데이터 패킷의 데이터 페이로드에 적용됩니다. 즉, 지정된 크기는8장에서 정의한 패킷의 데이터 필드,규약. 설정 패킷은 항상 8바이트입니다. 제어 파이프(기본 제어 파이프 포함)는 항상데이터 페이로드에 대해 wMaxPacketSize 값을 사용합니다 .엔드포인트는 구성 정보에서 최대 데이터 페이로드 크기 값을 보고합니다. USB전송된 데이터 페이로드가 정확히 최대 크기일 필요는 없습니다. 즉, 데이터 페이로드가 더 적은 경우최대 크기보다 크면 최대 크기로 채울 필요가 없습니다.모든 호스트 컨트롤러는 8, 16, 32, 64바이트의 최대 데이터 페이로드 크기를 지원해야 합니다.전속 제어 엔드포인트의 경우 저속 제어 엔드포인트의 경우 최대 8바이트 데이터 페이로드 크기만,고속 제어 엔드포인트에 대한 최대 데이터 페이로드 크기는 64바이트에 불과합니다. 호스트 컨트롤러 없음더 크거나 더 작은 최대 데이터 페이로드 크기를 지원하는 데 필요합니다.Default Control Pipe의 최대 패킷 크기를 결정하기 위해 USB 시스템 소프트웨어장치 설명자를 읽습니다. 호스트는 장치 설명자의 처음 8바이트를 읽습니다. 장치항상 단일 패킷에서 이러한 초기 바이트 이상으로 응답합니다. 호스트가 시작 부분을 읽은 후장치 설명자, 이 기본 파이프의 wMaxPacketSize 필드(바이트 7의장치 설명자). 그런 다음 모든 후속 트랜잭션에 대해 올바른 크기를 허용합니다. 다른 모든 제어용엔드 포인트는, 최대 데이터 페이로드 크기가 구성 후에 공지되도록, USB 시스템 소프트웨어지원되는 크기보다 큰 엔드포인트로 데이터 페이로드가 전송되지 않도록 할 수 있습니다.끝점은 항상 끝점의 데이터 필드보다 작거나 같은 데이터 페이로드를 전송해야 합니다.wMaxPacketSize (9장 참조). 제어 전송이 하나의 데이터에 담을 수 있는 것보다 더 많은 데이터를 포함하는 경우현재 설정된 최대의 페이로드 크기는 모든 데이터 페이로드가 최대 크기로 필요나머지 데이터를 포함하는 마지막 데이터 페이로드를 제외하고.끝점에서 호스트로의 제어 전송의 데이터 단계는 끝점이 다음 중 하나를 수행할 때 완료됩니다.다음과 같은:•설정 단계에서 지정된 양의 데이터를 정확히 전송했습니다.•페이로드 크기가 wMaxPacketSize 보다 작은 패킷을 전송하거나 길이가 0인 패킷을 전송합니다.데이터 단계가 완료되면 호스트 컨트롤러는 계속 진행하는 대신 상태 단계로 진행합니다.다른 데이터 트랜잭션으로 Host Controller가 Data단계가 완료되면 끝점은 섹션 5.3.2에 설명된 대로 파이프를 중지합니다. 데이터가 예상보다 큰 경우페이로드가 엔드포인트에서 수신되면 제어 전송에 대한 IRP가 중단/폐기됩니다.호스트에서 끝점으로 제어 전송의 데이터 단계는 모든 데이터가 완료되면 완료됩니다.양도됨. 엔드포인트가 호스트로부터 예상보다 큰 데이터 페이로드를 수신하면 파이프가 중지됩




이러한 요구 사항을 통해 호스트와 장치 간의 제어 전송이 버스를 통해 정기적으로 이동할 수 있습니다."최선의 노력"으로.
=>Best Effort

USB 시스템 소프트웨어는 재량에 따라 특정 끝점에 대한 제어 전송 속도를 변경할 수 있습니다.끝점 및 해당 클라이언트 소프트웨어는 제어 전송에 대해 특정 서비스 속도를 가정할 수 없습니다. 컨트롤엔드포인트는 단일(마이크로)프레임에서 0개 이상의 전송을 볼 수 있습니다. 소프트웨어에서 사용할 수 있는 버스 시간클라이언트와 그 끝점은 다른 장치가 시스템에 삽입되거나 시스템에서 제거될 때 변경될 수 있습니다.또한 다른 장치 끝점에 대해 제어 전송이 요청되기 때문입니다.버스 주파수 및 (마이크로)프레임 타이밍은 성공적인 제어 전송의 최대 수를 제한합니다.어떠한 USB 시스템의 (마이크로) 내에. 성공적인 제어 풀 /의 저속 버스를 들어, 숫자프레임당 전송은 29개 미만의 전속 8바이트 데이터 페이로드 또는 4개 미만의 저속으로 제한됩니다.8 바이트의 데이터 페이로드. 고속 버스의 제어 전송의 수 이하로 제한된다마이크로프레임당 32개의 고속 64바이트 데이터 페이로드




엔드포인트는 컨트롤의 데이터 및 상태 트랜잭션 동안 장치 특정 시간 동안 사용 중일 수 있습니다.옮기다. 엔드포인트가 사용 중이라고 표시하는 이 시간 동안(자세한 내용은 8장 및 9장 참조세부 정보), 호스트는 나중에 트랜잭션을 다시 시도합니다.이전에 시작된 제어 전송이 완료되기 전에 끝점에서 설정 트랜잭션을 수신한 경우장치는 현재 전송/작업을 중단하고 새 제어 설정 트랜잭션을 처리해야 합니다. 설정트랜잭션은 일반적으로 이전 제어 전송이 완료되기 전에 전송되어서는 안 됩니다. 그러나 만약예를 들어 버스의 오류로 인해 전송이 중단되면 호스트는 다음 설정 트랜잭션을 보낼 수 있습니다.끝점의 관점에서 시기상조




전제조건으로 파이단에서 신뢰할수있는 데이터가 온다고 가정(CRC등)


5.6 등시성 전송USB가 아닌 환경에서 등시성 전송은 일반적으로 일정한 속도, 오류-관용 전송. USB 환경에서 isochronous 전송 유형을 요청하면 요청자에게 제공됩니다.다음과 함께:•제한된 대기 시간으로 USB 대역폭에 대한 액세스 보장•파이프에 데이터가 제공되는 한 파이프를 통해 일정한 데이터 전송률 보장•오류로 인한 전송 실패의 경우 데이터 전송을 재시도하지 않음USB 등시 전송 유형은 등시 소스 및 대상을 지원하도록 설계되었지만이 전송 유형을 사용하는 소프트웨어가 전송 유형을 사용하기 위해 실제로 등시성일 필요는 없습낟.




케이블의 길이는 5m 이므로 루트허브에서 말하는 노드까지의 최장거리는 30m이다.
=> 호스트에서 알수없으니 상관없는 요구사항이다.


허브는 호스트 컨트롤러에서 허브디바이스로 인식된다. USB에서는 각 디바이스를 식별하기 위해 어드레스를 할당하지만 그 어드레스는 7비트를 사용하므로 USB 시스템은 127개의 디바이스를 사용할 수 있다.(허브까지 포함)



하드웨어 상황도 정의해야지
허브와 연결된 씨타입 맥북



USB 논리적디바이스(Endpoint),
LogicalUsbDevice는 스펙상 Endpoint에 해당하는 논리적인 도메인이다. 스펙의 용어를 그대로 도메인에 사용하는 경우 스펙에 매우 익숙한 개발자에게는 이해가 쉬울 수 있으나 직관적인 구조의 이해를 이해 명명하였다. 즉, USB Host Controller, USB System SW, Client SW라는 3개의 레이어 중 USB System SW 내에서만 적용되는 논리적인 개념이다.
=> 아닌데 스펙에도 논리적 디바이스라고 말하는거 같은데 확인
=> USB 논리적 디바이스는 USB 시스템에서 하나의 Endpoint로 표현되며, Endpoint는 한 개의 적용할 인터페이스에 그룹화 되어 Endpoint 집합으로 주어진다.

Pipe


도메인 모델 1 .. * 이런거 할수있지않나?
엔드포인트 1 --- 1 파이프


USB 디바이스는 다양한 성능을 가지고 있으나 호스트와의 송수신을 위해 동일한 기본 인터페이스를 가지고 있다. 즉, 호스트가 각종 디바이스를 동일한 방법으로 관리할 수 있다. 확인과 설정을 위해 디바이스는 자신의 정보를 호스트로 보고하며 포맷은 모든 디바이스에 대해 공통적인 부분과 각 디바이스에 특별한 부분으로 구분될 수 있다.



뎁스 제한이 있지만 뎁스 제한 내에서는 동등한 논리적인 디바이스로 인식한다.



􀁺 Host Controller Driver (HCD)

USB 호스트 컨트롤러와 USB 시스템 소프트웨어 사이에서의 인터페이스를 담당한다. 이것을 통해서 호스트 소프트웨어가 호스트 컨트롤러의 구현에 관계없이 프로그래밍을 가능하게 해준다. 한 개의 USB 드라이버는 호스트 컨트롤러의 구현에 대해서 특별한 정보가 없더라도 다른 호스트 컨트롤러를 지원할 수 있다.

􀁺 USB Driver (USBD)

USB 시스템 소프트웨어와 클라이언트 소프트웨어사에서의 인터페이스를 담당한다. 이러한 인터페이스는 클라이언트로 하여금 USB디바이스를 좀 더 원활하게 제어할 수 있도록 해준다. USB의 논리적 디바이스는 USB시스템에게는 Endpoint들의 집합으로 보인다. Endpoint들은 인터페이스를 구현하는 Endpoint 셋들로 그룹 되어진다. 클라이언트 소프트웨어는 인터페이스들을 Endpoint 셋과 관련된 파이프 번들을 사용하여 다루게 되며 호스트 컨트롤러 또는 전송방향에 따른 USB 디바이스는 전송될 데이터를 패킷화하게 된다. 호스트에서의 소프트웨어는 일견의 통신 흐름들을 통해서 논리적 디바이스와 통신한다.

=> 이것도 논리적인 도메인으로 나와야 한다. 레이어드 아키텍처라면 앱스트랙트 인터페이스를 써야하지만 도메인에도 표현되어야할지 아직 모르겟다.



클라이언트 소프트웨어의 파이프 번들과 USB SYSTEM SW의 Default Pipe(Endpoint 0)가 이거네, USB Wire의 매핑관계가 잇는가? 있다면 저장해야 하는가?
=> 흠...파이프 번들은 시스템 소프트웨어는 관리하면 안되나?

이는 호스트상의 버퍼와 USB 디바이스상의 Endpoint를 연결을 할 수 있게 한다.


호스트 컨트롤러까지 시스템을 끌어들여서 매핑하는거까지 구현해볼까?



호스트는 클라이언트 소프트웨어가 있고 메모리 버퍼들이 존재하며 각각의 버퍼에는 Pipe가 연결되어 있다. USB 논리적 디바이스는 Endpoint가 존재하며 이 또한 Pipe가 연결되어 호스트와 통신흐름의 통로가 된다. 호스트의 S/W는 통신의 셋을 통하여 논리적 디바이스와 통신하게 된다.
=> 각각의 버퍼를 논리적 개념의 Pipe같은 도메인으로 인식해서 실제로는 버퍼에 쓰고 읽지만 엔드포인트와 통신하는 느낌을 주자




하나의 Endpoint는 통신의 흐름의 종단이며 각 고유의 ID를 갖고 USB 디비이스 내에 존재하게 된다. 각 USB 논리적 디바이스는 Endpoint의 집합체이다. 각 USB 논리적 디바이스는 시스템에 연결될 때 시스템에 의하여 독립적인 주소를 할당받는다. 그리고 각 Endpoint는 설정된 시간 내에 번호를 할당받게 된다. Endpoint는 데이터 전송의 방향의 정보 (input device – host, output host – device)를 갖는다. 그리고 디바이스의 주소, 번호, 방향의 구성체라 할 수 있다. 또한 전송의 형태를 정의한다.



엔드포인트0를 제어 파이프라고 명명하자.
Stream Pipe는 USB에서 정의 되지 않은 구조의 파이프를 통해서 데이터를 전송하지만, Message의 경우에는 USB에서 정의된 구조의 파이프를 통해서 데이터를 전송하게 된다. Endpoint 0을 포함한 두개의 Endpoint를 기본 제어 Pipe라고 부른다.


3-4 Non-Endpoint 0

Function들은 구현을 위해서 필요한 부가적인 Endpoint들을 가질 수 있다. 낮은 속도(Low Speed)의 Function들은 2개의 선택적인 Endpoint를 가질 수 있고, 풀 속도(Full Speed)의 Function들은 프로토콜에 따라 입력 Endpoint들과 출력 Endpoint들에 대해서 각각 최대 15개의 Endpoint를 가질 수 있다.
USB시스템 S/W는 기본제어 Pipe의 오너쉽을 가지고 있으며 다른 클라이언트 S/W가 이 Pipe를 사용할 수 있도록 중재한다.



클라이언트 S/W는 I/O요청패킷(IRPs)를 이용하여 데이터 요청을 Pipe에 전달하며, IRP규격은 OS에서 정의 한다.


클라이언트 S/W는 버스 트랜잭션이 완료된 것을 알린다. 펜딩된 IRP가 없고 현재 Pipe를 사용하지 않는 다면, Pipe는 Idle상태가 되고 호스트 컨트롤러도 Pipe에 관련된 작업을 수행하지 않는다. 만약 Non_Isochronous Pipe의 IRP 패킷에서 3개의 버스 오류 혹은 Stall 전송이 이루어지게 되면 IRP는 취소되며 나머지 IRP도 재전송 되고 더 이상의 작업을 진행하지 않는다. 클라이언트 S/W가 이를 복구하게 된다.



만약에 구조라면,
컨트롤 파이프, 데이터 파이프 구분 / 단방향 파이프, 양방향 파이프
=> 이럴수있겠고 두개의 인터페이스를 상속해야하고 ISP이다.
=> 또 스트림 파이프는 스트림 Pipe는 Bulk, Isochoronous, interrupt의 전송 형태에 사용된다. 이렇게 전송 형태에 따라 상속할 수 있다. => Interface의 extends


3-5-1 Stream Pipe

이 파이프는 데이터 컨텐트의 USB에서 필요하지 않은 구조의 버스 트랜잭션에서의 데이터를 패키하여 전송하는데 사용된다. 통신 흐름에서 항상 단일 방향만을 제공한다. 스트램 파이프를 통한 데이터 전송은 단일 클라이언트라고 생각되는 것과 상호 작용을 하게 된다. 주어진 방향의 반대 방향이 필요하면 다른 스트림 Pipe를 개설하여야 한다.


USB시스템 S/W는 여러 개의 요청이 동시에 메시지 Pipe에 전송되지 않게 보장하여야 한다. 하나의 디바이스는 메시지 Pipe당 같은 시간에 한 개만의 요청을 처리 할 수 있다. 호스트상의 다수의 S/W 클라이언트들은 기본 제어 Pipe를 통하여 요청을 만들 수 있다. 그러나 디바이스에게는 먼저 들어간 것이 먼저 나오는 순서로 전송된다. 디바이스는 데이터/상태 스테이지 동안 정보들의 흐름을 조정할 수 있다.(FIFO)


하나의 메시지 Pipe는 양방향을 갖는 한 개의 Endpoint 번호만 있으면 된다. 메시지 Pipe는 제어 전송 형태를 지원한다. 각 USB 디바이스는 하나의 메시지 Pipe로 기본 제어 Pipe를 사용하게 된다. 이 Pipe는 USB 시스템 S/W가 사용하게 된다


USB 시스템은 호스트와 디바이스간의 제어 전송을 지원하기 위하여 최대한 노력하여야 한다. Function과 그의 클라이언트 S/W는 제어 전송을 위하여 특별한 버스 접근 주파수 혹은 대역폭을 요청할수 없다. USB 시스템 S/W만이 이들을 제약 할 수 있다.


􀁺 USB 드라이버(USBD) : IRP를 디바이스 엔드포인트 Call로 변환



3. USB1.1 제품을 USB2.0 장치들과 공용 가능합니까?

USB2.0은 USB 1.1과 backward 호환성이 된다. 따라서 모든 USB1.1 장치들은 USB2.0 장치들과 같이 사용할 수 있으나 USB 1.1 장치로서 동작된다.



호스트가 액세스할 때 전송하면 NAK로 응답합니다. 끝점은 인터럽트 데이터만 제공해야 합니다.소프트웨어 클라이언트가 IRP 완료에 대해 잘못 알림을 받는 것을 방지하기 위해 보류 중인 인터럽트가 있을 때. ㅏ길이가 0인 데이터 페이로드는 유효한 전송이며 일부 구현에 유용할 수 있습니다.



대량전송의 경우
엔드포인트가 다음 중 하나를 수행하면 대량 전송이 완료됩니다.•예상되는 데이터의 양을 정확히 전송했습니다.•페이로드 크기가 wMaxPacketSize 보다 작은 패킷을 전송하거나 길이가 0인 패킷을 전송합니다




5.11 Bus Access for Transfers
5.11 환승을 위한 버스 접근호스트와 USB 장치 간의 데이터 전송을 수행하려면 USB대역폭. 다양한 등시성 및 비동기식 장치를 지원하려면 각 장치의전송 요구 사항이 수용됩니다. 장치에 버스 대역폭을 할당하는 프로세스를전송 관리. 호스트에는 정보 흐름을 조정하는 여러 엔터티가 있습니다.USB: 클라이언트 소프트웨어, USB 드라이버(USBD) 및 호스트 컨트롤러 드라이버(HCD). 의 구현자이러한 엔터티는 버스 액세스와 관련된 주요 개념을 알아야 합니다.•전송 관리: USB를 통한 통신 흐름을 지원하는 개체 및 개체•트랜잭션 추적: 트랜잭션이 이동할 때 트랜잭션을 추적하는 데 사용되는 USB 메커니즘USB 시스템•버스 시간: 버스에서 정보 패킷을 이동하는 데 걸리는 시간•장치/소프트웨어 버퍼 크기: 버스 트랜잭션을 지원하는 데 필요한 공간•버스 대역폭 회수: 다른 전송에 할당되었지만사용되지 않으며 이제 제어 및 대량 전송에서 재사용할 수 있습니다.이전 섹션에서는 클라이언트 소프트웨어가 기능과 어떤 관련이 있고 논리적 흐름이 무엇인지에 중점을 두었습니다.두 엔티티 사이의 파이프를 통해. 이 섹션에서는 호스트의 다양한 부분과 그 부분이 어떻게USB를 통한 데이터 이동을 지원하려면 상호 작용해야 합니다. 이 정보는 기기에서도 관심을 가질 수 있습니다.구현자는 클라이언트가 전송을 요청할 때 호스트가 수행하는 작업의 측면과 전송 방법을 이해하도록 합니다.그 전송은 장치에 표시됩니다





.11.1 전송 관리전송 관리에는 이동하기 위해 서로 다른 개체에서 작동하는 여러 엔터티가 포함됩니다.버스를 통한 거래:•클라이언트 소프트웨어: 호출 및USBD 인터페이스로 IRP를 요청하는 콜백.•USB 드라이버(USBD): 클라이언트 IRP의 데이터를 장치 끝점으로/에서 장치 끝점으로 변환합니다.적절한 HCD. 단일 클라이언트 IRP에는 하나 이상의 전송이 포함될 수 있습니다.•호스트 컨트롤러 드라이버(HCD): IRP를 트랜잭션으로/트랜잭션에서 변환합니다(호스트 컨트롤러의 요구에 따라).구현) 및 호스트 컨트롤러가 조작할 수 있도록 구성합니다. 상호작용HCD 및 해당 하드웨어는 구현에 따라 다르며 USB 사양 범위를 벗어납니다.•호스트 컨트롤러: 트랜잭션을 수행하고 기능별 이동을 위해 패킷을 통해 버스 활동을 생성합니다.각 트랜잭션에 대한 버스 전체의 데이터.그림 5-13은 클라이언트 소프트웨어와 클라이언트 소프트웨어 간의 정보 흐름으로 엔터티가 구성되는 방식을 보여줍니다.USB. 각 엔터티의 주요 관심 개체는 엔터티 간의 인터페이스에 표시됩니




5.11.1.1 클라이언트 소프트웨어클라이언트 소프트웨어는 기능으로 수행해야 하는 전송을 결정합니다. 적절한 운영을 사용합니다.IRP를 요청하기 위한 시스템별 인터페이스. 클라이언트 소프트웨어는 파이프 세트(즉,인터페이스) 기능을 조작해야 합니다. 클라이언트는 모든 버스 접근을 인지하고 준수합니다.각 전송 유형에 대해 앞에서 설명한 대로 대역폭 제약 조건. 클라이언트의 요청소프트웨어는 USBD 인터페이스를 통해 제공됩니다.일부 클라이언트는 운영 체제에서 정의한 다른 장치 클래스 인터페이스를 통해 USB 기능을 조작할 수 있습니다.시스템과 직접 USBD 호출을 하지 않을 수 있습니다. 그러나 항상 가장 낮은 수준의 클라이언트가 있습니다.IRP를 USBD에 전달하기 위해 USBD 호출을 수행합니다. 제시된 모든 IRP는 다음을 준수해야 합니다.파이프가 설정될 때 설정된 사전 협상된 대역폭 제약 조건. 기능이 비에서 이동된 경우USB 환경에서 USB를 통해 기능 하드웨어를 직접 조작했을 드라이버메모리 또는 I/O 액세스는 USB 환경에서 현재 상호 작용하는 가장 낮은 클라이언트 소프트웨어입니다.USBD 드라이버의 USB 기능을 조작합니다.클라이언트 소프트웨어가 기능 이전을 요청하고 요청이 처리된 후 클라이언트는소프트웨어는 IRP의 완료 상태에 대한 알림을 받습니다. 전송이 기능-호스트와 관련된 경우데이터 전송이 완료되면 클라이언트 소프트웨어는 완료된 IRP와 관련된 데이터 버퍼의 데이터에 액세스할 수 있습니다.USBD 인터페이스는 10장에 정의되어 있습니다.5.11.1.2 USB 드라이버USBD(Universal Serial Bus Driver)는 다음 두 가지 일반적인 시간에 버스 액세스를 중재하는 데 관여합니다.•구성 중에 장치가 버스에 연결되어 있는 동안•일반 환승 시장치가 연결되고 구성되면 USBD가 관련되어 원하는 장치가구성은 버스에서 수용할 수 있습니다. USBD는 구성 요청을 수신합니다.원하는 장치 구성을 설명하는 구성 소프트웨어: 끝점, 전송 유형, 전송기간, 데이터 크기 등 USBD는 대역폭에 따라 구성 요청을 수락하거나 거부합니다.가용성 및 버스에서 해당 요청 유형을 수용할 수 있는 능력. 요청을 수락하면 USBD원하는 유형의 요청자를 위한 파이프를 생성하고전송 유형. 주기적 끝점에 대한 대역폭 할당은 장치가구성되고 일단 이루어지면 장치를 변경하지 않고 대역폭 할당을 해제할 수 있습니다.구성.USBD의 구성 측면은 일반적으로 운영 체제에 따라 다르며추가(중복) 인터페이스 정의를 피하기 위해 운영 체제의 구성 기능.장치가 구성되면 소프트웨어 클라이언트는 IRP에 요청하여 장치와 해당 기능 간에 데이터를 이동할 수 있습니다.끝점.5.11.1.3 호스트 컨트롤러 드라이버호스트 컨트롤러 드라이버(HCD)는 진행 중인 IRP를 추적하고 USB대역폭 및 (마이크로)프레임 시간 최대값은 절대 초과되지 않습니다. 파이프에 대한 IRP가 만들어지면HCD는 트랜잭션 목록에 추가합니다. IRP가 완료되면 HCD는 요청 소프트웨어에 알립니다.IRP 완료 상태의 클라이언트. IRP가 기능에서 데이터 전송과 관련된 경우소프트웨어 클라이언트에서 데이터는 클라이언트 지정 데이터 버퍼에 배치되었습니다.IRP는 운영 체제 종속적인 방식으로 정의됩니




멀티코어로 여러개의 플로우를 관리한다면?
실제로는 물리버스는 하나라서 안되나


그림 Figure 5-15가 참고할만한듯




5.11.4 함수와 소프트웨어에서 버퍼 크기 계산하기클라이언트 소프트웨어와 기능은 모두 대기 중인 데이터 트랜잭션을 위한 버퍼 공간을 제공해야 합니다.버스를 켭니다. 비등시성 파이프의 경우 이 버퍼 공간은 다음 버퍼를 저장할 만큼 충분히 커야 합니다.데이터 패킷. 주어진 엔드포인트에 대해 둘 이상의 트랜잭션 요청이 보류 중인 경우 각 엔드포인트에 대한 버퍼링거래를 제공해야 합니다. 함수를 버퍼링하는 정확한 절대 최소값을 계산하는 방법은 다음과 같습니다.클라이언트 소프트웨어와 기능 사이에 정의된 특정 상호 작용 때문에 필요합니다.이 사양의 범위.호스트 컨트롤러는 보류 중인 트랜잭션을 무제한으로 지원할 수 있을 것으로 예상됩니다.버스는 버퍼 및 설명자 공간 등을 위해 사용 가능한 시스템 메모리에 종속됩니다. 호스트 컨트롤러는 허용됩니다.트랜잭션 요청을 허용하는 미래의 (마이크로) 프레임 수를 제한합니



Figure 5-17에서 상위 드라이버와의 관계가 좀 나오는듯



USB 데이터 모델은 장치에 자연스러운 샘플 크기와 속도가 있다고 가정합니다.




7.2.1 장치 등급다양한 장치 클래스의 전원 및 싱크 요구 사항은 다음을 도입하여 단순화할 수 있습니다.단위 부하의 개념입니다. 단위 부하는 100mA로 정의됩니다. 장치가 그릴 수 있는 단위 부하의 수는시간 경과에 따른 평균이 아닌 절대 최대값입니다. 장치는 하나의 단위 부하에서 저전력이거나 고출력일 수 있습니다.최대 5개의 단위 부하를 소모합니다. 모든 장치는 기본적으로 저전력으로 설정되어 있습니다. 고출력으로의 전환이 진행 중입니다.소프트웨어 제어. 허용하기 전에 적절한 전원을 사용할 수 있는지 확인하는 것은 소프트웨어의 책임입니다.고전력을 소모하는 장치.USB는 다양한 전원 공급 및 전력 소비 에이전트를 지원합니다. 여기에는 다음이 포함됩니다.•루트 포트 허브 : USB 호스트 컨트롤러에 직접 연결됩니다. 허브 전원은 동일한 것에서 파생됩니다.소스를 호스트 컨트롤러로 사용합니다. AC 또는 DC 외부에서 작동 전원을 얻는 시스템은 다음을 수행해야 합니다.각 포트에 최소 5개의 단위 부하를 공급합니다. 이러한 포트를 고전력 포트라고 합니다. 배터리 구동시스템은 하나 또는 다섯 개의 단위 부하를 공급할 수 있습니다. 하나의 단위 부하만 공급할 수 있는 포트를 저전력 포트라고 합니다.전원 포트.•버스 전원 허브 : 내부 기능 및 다운스트림 방향 포트에 대한 모든 전원을 끌어옵니다.허브의 상류 방향 포트에 있는 V BUS . 버스 전원 허브는 최대 하나의 단위 부하만 사용할 수 있습니다.구성 후 전원 공급 및 5개 단위 부하. 구성 권한은 할당 간에 분할됩니다.허브, 제거할 수 없는 기능 및 외부 포트. 버스 전원 공급 허브의 외부 포트는 다음을 제공할 수 있습니다.해당 허브의 다른 포트에 대한 전류 소비에 관계없이 포트당 하나의 단위 로드만 가능합니다. 허브는 다음과 같아야 합니다.허브가 활성 또는 일시 중단 상태에 있을 때 이 포트 전류를 공급할 수 있습니다.•자체 전원 허브 : 내부 기능 및 다운스트림을 향한 포트에 대한 전원이 공급되지 않습니다.V 버스 . 그러나 허브의 USB 인터페이스는 업스트림의 V BUS 에서 최대 하나의 단위 부하를 끌어올 수 있습니다.나머지 허브의 전원이 꺼졌을 때 인터페이스가 작동할 수 있도록 포트를 향하고 있습니다. 허브외부에서(USB에서) 작동 전원을 얻으려면 각 포트에 5개의 단위 부하를 공급해야 합니다. 배터리-전원 허브는 포트당 1개 또는 5개의 단위 부하를 공급할 수 있습니다.•저전력 버스 전원 기능 : 이러한 장치에 대한 모든 전원은 V BUS 에서 제공됩니다 . 그들은 그림을 그릴 수 없습니다언제든지 하나 이상의 단위 부하.•고전력 버스 전원 기능 : 이러한 장치에 대한 모든 전원은 V BUS 에서 제공됩니다 . 그들은 아니오를 그려야합니다전원을 켤 때 두 개 이상의 단위 부하가 발생하고 구성된 후 최대 5개의 단위 부하를 끌어올 수 있습니다.•자체 전원 기능 : USB 인터페이스가 작동할 수 있도록 V BUS 에서 최대 1개의 단위 부하를 끌어올 수 있습니다.나머지 기능의 전원이 꺼졌을 때. 다른 모든 전원은 외부(USB)에서 제공됩니다.원천.어떤 장치 도 상류 방향 포트에서 V BUS 에 전류를 공급(소스)해서는 안 됩니다. V BUS 에서업스트림을 향한 포트에서 장치는 전류를 끌어오기(싱크)만 할 수 있습니다. 풀업 저항에 전원을 공급하지 않을 수 있습니다.V BUS 가 존재 하지 않는 한 D+/D-에 있습니다(섹션 7.1.5 참조). V BUS 가 제거되면 장치는 전원을 제거해야 합니다.10초 이내에 D+/D- 풀업 저항에서. 전원을 켤 때 장치는 업스트림이직면 포트는 버스를 구동하지 않으므로 장치가 재설정 신호를 수신할 수 있습니다. 장치는 또한구성될 때까지 장치에서 끌어오는 최대 작동 전류가 하나의 단위 부하인지 확인합니다. 모든 장치버스에서 전력을 끌어오기 위해서는 버스의 활동 부족을 감지하고 일시 중단 상태로 들어가고 감소시킬 수 있어야 합니다.V BUS 의 전류 소비 (섹션 7.2.3 및 섹션 9.2.5.1 참조




Figure 7-42 => 전력공급관련. 전력공급량도 아랫단의 역할일까...? 과제 요구사항에 전원관리도 있는데 소설써보자
명령은 시스템 소프트웨어에서하고 허브컨트롤러가 땡겨오기?


43에는 허브 자체가 자체전원이 있는경우인거같은데 이거인거 같다.


7.2.1.2.1 과전류 보호
호스트 및 모든 자체 전원 공급 허브는 안전상의 이유로 과전류 보호를 구현해야 하며 허브는과전류 상태를 감지하고 USB 소프트웨어에 보고하는 방법이 있습니다. 총 전류다운스트림 대면 포트 그룹이 미리 설정한 값을 초과하면 과전류 보호 회로가또는 영향을 받는 모든 다운스트림 대면 포트의 전력을 줄입니다. 과전류 상태는 다음을 통해 보고됩니다.섹션 11.12.5에 설명된 대로 허브에서 호스트 컨트롤러로. 사전 설정 값은 5.0A를 초과할 수 없으며 반드시과도 전류(예: 전원 켜기 또는동적 연결 또는 재구성) 과전류 보호기를 트립하지 마십시오. 에 과전류 상태가 발생하는 경우USB의 후속 작동은 보장되지 않으며, 해당 조건이 제거되면전원을 켤 때 수행되는 것처럼 버스를 다시 초기화하는 데 필요합니다. 과전류 제한 메커니즘은 다음과 같아야 합니다.사용자의 기계적 개입 없이 재설정 가능. 폴리머 PTC 및 솔리드 스테이트 스위치는 다음의 예입니다.과전류 제한에 사용할 수 있는 방


펑션은 어떤 개념일까?




7.2.4 동적 연결 및 분리허브 또는 기능을 연결하거나 분리하는 행위는 다른 장치의 다른 장치 기능에 영향을 주어서는 안 됩니다.네트워크의 세그먼트. 함수의 플러그를 뽑으면 해당 함수와 호스트 간의 트랜잭션이 중지됩니다.그러나 이 기능이 연결된 허브는 이 상태에서 복구되고 호스트에 다음을 알립니다.포트가 분리되었습니다




AA_C1차_인증과제_Interim_김성후




허브인 디바이스가 연결되어도 최대개수나 뎁스를 안넘치면 동일한 논리적 디바이스로 인식한다. 서브 허브가 요구하는 전력에 대해서 best effort로 공급을 하지만 그럼에도 불구하고 서브 허브의 전력부족은 루트허브의 책임이 아니다.라고 정의하자


11.11 허브 포트 전원 제어자체 전원 허브에는 포트를 향한 다운스트림 전원 공급을 제어하는 ​​전원 스위치가 있을 수 있지만필요하지 않습니다. 버스 전원 허브에는 전원 스위치가 있어야 합니다. 전원 스위치가 있는 허브는 다음을 수행할 수 있습니다.모든 포트의 전원을 그룹/갱으로, 각 포트에 개별적으로 또는 임의의 수의 갱으로 전환하나 이상의 포트.허브는 Logical Power Switching 설정으로 전원 스위칭 지원 여부를 나타냅니다.wHubCharacteristics 의 모드 필드 . 허브가 포트별 전원 스위칭을 지원하는 경우 포트에 대한 전원은 다음과 같습니다.포트에 대한 SetPortFeature(PORT_POWER) 요청이 수신되면 켜집니다. 포트 전원이 꺼져 있습니다.포트가 전원이 꺼진 상태 또는 구성되지 않은 상태일 때. 허브가 집단 전원 스위칭을 지원하는 경우,그런 다음 갱의 모든 포트에 대한 전원이 켜집니다. 갱의 포트 중 하나가 수신SetPortFeature(PORT_POWER) 요청. 갱의 모든 포트가 꺼지지 않는 한 갱의 전원이 꺼지지 않습니다.전원이 꺼진 상태 또는 구성되지 않은 상태입니다. 참고로 포트의 전원은 다음과 같은 방법으로 켜지지 않습니다.C_HUB_LOCAL_POWER 및 로컬 전원 상태(inwHubStatus )는 요청이 실행되고 PORT_POWER 기능이 실행될 때 1B로 설정됩니다.켜집니다.전원 스위칭을 구현하기 위해 자체 전원 허브가 필요하지는 않지만 허브는 다음을 지원해야 합니다.모든 포트의 전원이 꺼진 상태입니다. 또한 허브는 PortPwrCtrlMask 를 구현해야 합니다 (모든 비트는1B) 허브에 USB 시스템 소프트웨어로 제어할 수 있는 전원 스위치가 없더라도.참고: 이전 버전의 USB 소프트웨어와의 호환성을 보장하기 위해 허브는 논리적wHubCharacteristics 의 전원 전환 모드 필드 . 이는 일부 SW 버전이 사용하지 않기 때문입니다.허브가 wHubCharacteristics 에서 포트가 포트를 지원하지 않음을 나타내는 경우 SetPortFeature() 요청전원 스위칭. 그렇지 않으면 wHubCharacteristics 의 Logical Power Switching Mode 필드 는사양의 이 버전으로 중복됩니다.전원 스위치가 없는 허브에 대한 논리적 전원 스위칭 모드의 설정은 다음을 반영해야 합니다.과전류가 보고되는 방식. 예를 들어 허브가 과전류 상태를 보고하는 경우포트를 기반으로 하는 경우 논리적 전원 스위칭 모드는 전원 스위칭이 다음임을 나타내도록 설정되어야 합니다.포트별로 제어됩니다.전원 스위치가 없는 허브의 경우 bPwrOn2PwrGood 을 0으로 설정해야 합니다.







등시성 전송때는 손실이 있을 수 있으나 그외의 경우에는 데이터 무결성이 전제되는데 이미 파이단에서 된다고 가정하자





11.12.6 열거 처리허브 장치 클래스 명령은 다운스트림 대면 포트 상태를 조작하는 데 사용됩니다. 장치가연결되면 장치 연결 이벤트가 허브에서 감지되고 상태 변경 인터럽트에서 보고됩니다. 주인상태 변경 보고서를 수락하고 포트에서 SetPortFeature(PORT_RESET)를 요청합니다. 일부로버스 리셋 시퀀스에서 속도 감지는 허브의 포트 하드웨어에 의해 수행됩니다.호스트에 의해 호출된 Get_Status(PORT) 요청은 "not PORT_LOW_SPEED 및PORT_HIGH_SPEED”는 고속으로 작동하는 다운스트림 방향 포트에 대한 표시입니다. 그만큼Get_Status(PORT)는 저전력에서 작동하는 다운스트림 방향 포트에 대해 "PORT_LOW_SPEED"를 보고합니다.속도. Get_Status(PORT)는 "not PORT_LOW_SPEED and not PORT_HIGH_SPEED"를 보고합니다.전속력으로 작동하는 하류 쪽 포트.장치가 포트에서 분리되면 포트는 상태 변경을 통해 상태 변경을 보고합니다.끝점과 포트는 고속 리피터에 다시 연결됩니다. 그러면 프로세스가 준비됩니다.다음 장치 연결 감지에서 반복됩니





240페이지 상태 다이어그램
=> 도메인보다는 도메인 시퀀스의 함수호출이 될수있다. 다 챙겨야 한다.
=> 그림 뒤에 상세설명이 잇다 이것도 나중에 또 보자


9.1.1.2 전원USB 장치는 외부 소스 및/또는 USB 장치가 연결된 허브를 통해 전원을 얻을 수 있습니다.첨부되어 있습니다. 외부 전원 공급 USB 장치를 자체 전원 공급 장치라고 합니다. 자체 전원 장치이지만USB에 연결되기 전에 이미 전원이 공급되었을 수 있으며 전원 공급 장치에 있는 것으로 간주되지 않습니다.USB에 연결되고 장치에 V BUS 가 적용될 때까지 상태를 유지 합니다.장치는 자체 전원 및 버스 전원 구성을 모두 지원할 수 있습니다. 일부 장치 구성둘 중 하나의 전원을 지원합니다. 다른 장치 구성은 장치가 자체 구성인 경우에만 사용할 수 있습니다.전원. 장치는 구성 설명자를 통해 전원 기능을 보고합니다. 현재전원은 장치 상태의 일부로 보고됩니다. 장치는 언제든지 전원을 변경할 수 있습니다.예를 들어 자가 전원에서 버스 전원으로. 구성이 두 전원 모드를 모두 지원할 수 있는 경우 전원해당 구성에 대해 보고된 최대값은 장치가 어느 모드에서든 V BUS 에서 끌어오는 최대값입니다.장치는 모드에 관계없이 이 최대값을 준수해야 합니다. 구성이 하나의 전원만 지원하는 경우모드 및 장치의 전원이 변경되면 장치는 현재 구성 및 주소를 잃게 됩니다.전원이 켜진 상태로 돌아갑니다. 장치가 자체 전원이 공급되고 현재 구성이 다음 이상을 요구하는 경우100mA에서 장치가 버스 전원으로 전환되면 주소 상태로 돌아가야 합니다. 자체 전원허브 컨트롤러에 전원을 공급하기 위해 V BUS 를 사용하는 허브는 로컬전원이 손실됩니다. 자세한 내용은 11.13절을 참조하십시오.연결 및 분리를 포함하여 포트 상태 변경을 감지하려면 허브 포트에 전원이 공급되어야 합니다. 버스-전원이 공급되는 허브는 구성될 때까지 다운스트림 전원을 제공하지 않습니다.구성 및 전원에서 허용하는 대로 전원을 공급합니다. USB 장치는 다음과 같을 수 있어야 합니다.전원이 처음 인가된 때부터 지정된 시간 내에 해결됩니다(7장 참조). 후포트에 대한 연결이 감지되면 호스트가 포트를 활성화할 수 있으며 이는 장치도 재설정합니다.포트에 부착되어 있습니다



속 작동이 가능한 장치는 전기 상태일 때 최대 속도로 성공적으로 재설정되어야 합니다.전속력으로 작동하는 환경. 장치가 성공적으로 재설정된 후 장치도장치 및 구성 설명자 요청에 성공적으로 응답하고 적절한 정보를 반환합니다.장치는 최대 속도로 작동할 때 의도한 기능을 지원하거나 지원하지 못할 수 있습니다


9.1.1.4 주소모든 USB 장치는 처음 전원이 공급되거나 장치가 재설정된 후에 기본 주소를 사용합니다. 각USB 장치는 연결 후 또는 재설정 후 호스트에 의해 고유한 주소가 할당됩니다. USB 장치일시 중단되는 동안 할당된 주소를 유지합니다.USB 장치는 장치가 현재 고유하게 할당되었는지 여부에 관계없이 기본 파이프의 요청에 응답합니다.주소 또는 기본 주소를 사용 중입니다



9.1.2 버스 열거USB 장치가 USB에 연결되거나 제거될 때 호스트는 버스라고 하는 프로세스를 사용합니다.필요한 장치 상태 변경을 식별하고 관리하기 위한 열거. USB 장치가 연결된 경우전원이 공급된 포트에서 다음 작업이 수행됩니다.1. USB 장치가 연결된 허브는 현재 상태에 대한 응답을 통해 이벤트를 호스트에 알립니다.파이프 변경(자세한 내용은 섹션 11.12.3 참조). 이 시점에서 USB 장치는전원이 켜진 상태와 연결된 포트가 비활성화됩니다.2. 호스트는 허브를 쿼리하여 변경 사항의 정확한 특성을 확인합니다.3. 이제 호스트가 새 장치가 연결된 포트를 알고 있으므로 호스트는 다음을 기다립니다.삽입 프로세스가 완료되고 장치의 전원이 안정되기 위해서는 최소 100ms가 필요합니다.그런 다음 호스트는 해당 포트에 대해 포트 활성화 및 재설정 명령을 실행합니다. 에 대해서는 섹션 7.1.7.5를 참조하십시오.장치 재설정을 통한 이벤트의 순서 및 연결 타이밍.4. 허브는 해당 포트에 필요한 재설정 처리를 수행합니다(섹션 11.5.1.5 참조). 리셋할 때신호가 해제되고 포트가 활성화되었습니다. USB 장치는 이제 기본 상태이며 그림을 그릴 수 있습니다.V BUS 에서 100mA 이하 . 모든 레지스터와 상태가 재설정되었으며 응답합니다.기본 주소.5. 호스트는 USB 장치에 고유한 주소를 할당하여 장치를 주소 상태로 이동합니다.6. USB 장치가 고유한 주소를 받기 전에 기본 제어 파이프는 여전히 다음을 통해 액세스할 수 있습니다.기본 주소. 호스트는 실제 최대 데이터 페이로드를 결정하기 위해 장치 설명자를 읽습니다.이 USB 장치의 기본 파이프가 사용할 수 있는 크기입니다.7. 호스트는 각 구성 0을 읽어 장치에서 구성 정보를 읽습니다.n -1, 여기서 n 은 구성 수입니다. 이 프로세스를 완료하는 데 몇 밀리초가 걸릴 수 있습니다
8. 구성 정보와 USB 장치가 사용되는 방식에 따라 호스트는장치에 구성 값. 장치는 이제 구성됨 상태이고 모든 끝점은이 구성은 설명된 특성을 사용했습니다. USB 장치는 이제선택한 구성에 대한 설명자에 설명된 V BUS 전력의 양입니다. 기기에서이제 사용할 준비가 되었습니다.USB 장치가 제거되면 허브는 다시 호스트에 알림을 보냅니다. 장치 분리연결된 포트를 비활성화합니다. 분리 알림을 받으면 호스트가 업데이트됩니다.로컬 토폴로지 정


9.3에 USB Device Requests라고 세부 구현적인 부분있음 봐바야함
=> NumberOfByte가 있네. 근데 운영체제단에서 복사할때처럼 그런 단위는 아닌듯



9.4 Standard Device Requests 이게 오퍼레이션이 될수 있을까?


9.6 => 진짜 디스크립터 => 요거 중요



9.63에 표에 최대전력이랑 이런거 다 나와있음


9.6.6에 엔드포인트 디스크립터
=> 인 끝점인지 아웃 끝점인지
전송유형(등시성인가 인터럽트인가 이런거)




디폴트 파이프만 내꺼면 디폴트 파이프는 도메인이고(=> 내가 능동적으로 데이터를 주고받을 수 있음? 아니면 이것도 걍 빌려주는건가? enum과정은 내가 하는거 아닌가)
상위 파이프들의 정보를 담고있는 컴포넌트정도가 또 도메인이 되겠다.




USB 시스템은 호스트 컨트롤러를 사용하여 호스트와 USB 장치 간의 데이터 전송을 관리합니다.USB 시스템과 호스트 컨트롤러 간의 인터페이스는 하드웨어 정의에 따라 다릅니다


USBD는 다음으로 구성된 I/O 요청 패킷(IRP) 형식의 데이터 전송 메커니즘을 제공합니다.특정 파이프를 통해 데이터를 전송하라는 요청입니다. 데이터 전송 메커니즘을 제공하는 것 외에도USBD는 클라이언트에게 조작할 수 있는 USB 장치의 추상화를 제공할 책임이 있습니다.구성 및 상태 관리. 이 추상화의 일부로 USBD는 기본 파이프를 소유합니다(참조




전반적으로 호스트 계층은 다음 기능을 제공합니다.•USB 장치의 부착 및 제거 감지•호스트와 USB 장치 간의 USB 표준 제어 흐름 관리•호스트와 USB 장치 간의 데이터 흐름 관리•상태 및 활동 통계 수집•다음을 포함하여 호스트 컨트롤러와 USB 장치 간의 전기 인터페이스 제어제한된 양의 전력 제공




USBD는 자신이 소유하고 사용하는 기본 파이프를 클라이언트와 공유하는 것을 지원합니다. 또한장치와 관련된 다른 제어 파이프에 대한 액세스를 제공합니다



파이프는 전송할 데이터의 전달 요구 사항에 따라 몇 가지 특성을 갖습니다.이러한 특성의 예는 다음과 같습니다.•데이터를 전송해야 하는 속도•데이터가 일정한 속도로 제공되는지 또는 산발적으로 제공되는지 여부•데이터 전송이 지연될 수 있는 기간•전송 중인 데이터의 손실이 치명적인지 여부USB 장치 끝점은 특정 파이프에 필요한 특성을 설명합니다. 끝점이 설명되어 있습니다.USB 장치의 특성화 정보의 일부로. 자세한 내용은 9장을 참조하십시오




10.1.4 상태 및 활동 통계 수집호스트와 USB 장치 간의 모든 제어 및 데이터 전송을 위한 공통 통신자로서 USB시스템과 호스트 컨트롤러는 상태 및 활동 정보를 추적할 수 있는 위치에 있습니다. 그런정보는 요청 시 호스트 소프트웨어에 제공되어 해당 소프트웨어가 상태 및활동 정보. 이 사양은 추적해야 하거나 추적해야 하는 특정 정보를 식별하지 않습니다.활동 및 상태 정보를 보고하기 위한 특정 형식이 필요합


10.1.5 전기 인터페이스 고려 사항호스트는 루트 허브에 연결된 USB 장치에 전원을 제공합니다. 포트에서 제공하는 전력량7장에 명시되어 있습니다



장치가 연결되면 허브 드라이버는 변경을 감지하는 허브로부터 알림을 받습니다. 그만큼허브 드라이버는 허브에서 제공한 정보를 사용하여 USBD에서 장치 식별자를 요청합니다. 그만큼USBD는 차례로 해당 장치에 대한 기본 파이프를 설정하고 장치 식별자를 허브 드라이버에 반환합니다.이제 장치를 사용하도록 구성할 준비가 되었습니다. 각 장치에는 다음 세 가지 구성이 필요합니다.해당 장치를 사용할 준비가 되기 전에 완료해야 합니다.1. 장치 구성: 여기에는 장치의 모든 USB 매개변수 설정 및장치에 표시되는 USB 호스트 리소스입니다. 이것은 구성을 설정하여 수행됩니다.장치의 값. 대체 설정과 같은 제한된 구성 변경이 허용됩니다.장치를 완전히 재구성하지 않고 장치가 구성되면 그 관점에서 볼 때 다음과 같습니다.사용할 준비가 되었습니다.2. USB 구성: 클라이언트가 사용할 준비가 된 USBD 파이프를 실제로 생성하기 위해 추가 USB장치에 표시되지 않는 정보는 클라이언트가 지정해야 합니다. 로 알려진 이 정보는파이프에 대한 정책은 클라이언트가 파이프를 사용하는 방법을 설명합니다. 여기에는 다음과 같은 항목이 포함됩니다.클라이언트가 하나의 IRP로 전송할 최대 데이터 양, 클라이언트의 최대 서비스 간격클라이언트의 알림 ID 등을 사용할 것입니다.3. 기능 구성: 구성 유형 1 및 2가 완료되면 파이프는USB의 관점에서 완전히 사용할 준비가 되었습니다. 그러나 추가 공급업체 또는 클래스별클라이언트가 파이프를 실제로 사용하기 전에 설정이 필요할 수 있습니다. 이 구성은 개인 문제입니다장치와 클라이언트 사이에 있으며 USBD에 의해 표준화되지 않았습니




구성 소프트웨어는 먼저 장치 설명자를 읽은 다음 가능한 각 장치에 대한 설명을 요청합니다.구성. 장치 드라이버와 같은 특정 클라이언트를 로드하기 위해 제공된 정보를 사용할 수 있습니다.처음에 장치와 상호 작용합니다. 구성 소프트웨어(해당 장치의 입력 포함)드라이버는 장치에 대한 구성을 선택합니다. 장치 구성을 설정하면 모든 엔드포인트가 설정됩니다.장치에서 USBD 클라이언트의 데이터 전송에 사용할 인터페이스 모음을 반환합니다. 각인터페이스는 단일 클라이언트가 소유한 파이프 모음입니다.이 초기 구성은 인터페이스에 대한 기본 설정과 각 인터페이스에 대한 기본 대역폭을 사용합니다.끝점. USBD 구현은 클라이언트가 다음과 같은 경우 대체 인터페이스를 지정하도록 추가로 허용할 수 있습니다.초기 구성을 선택합니다. USB 시스템은 지원에 필요한 리소스를 확인합니다.사용 가능한 경우 필요한 대역폭을 할당합니다. 에 대해서는 섹션 10.3.2를 참조하십시오.자원 관리에 대한 토론.이제 장치가 구성되었지만 생성된 파이프는 아직 사용할 준비가 되지 않았습니다. USB 구성은클라이언트가 각 파이프와 상호 작용하는 방법을 지정하는 정책을 설정하여 각 파이프를 초기화할 때 수행파이프. 지정된 정보 중 클라이언트의 최대 서비스 간격 및 알림정보. 정책을 설정한 결과 USB 시스템이 취하는 조치 중 다음을 결정합니다.클라이언트가 제공한 데이터 버퍼 공간 이상으로 필요한 버퍼 작업 공간의 양입니다. 크기필요한 버퍼의 수는 클라이언트가 선택한 사용량과 전송당 필요에 따라 다릅니다.USB 시스템.클라이언트는 IRP가 완료되거나, 성공적으로 또는 오류로 인해 알림을 받습니다. 클라이언트는 또한보류 중인 IRP의 상태를 확인하기 위해 USB 알림과 독립적으로 깨어납니다.클라이언트는 대체 설정 활성화와 같은 구성 수정을 선택할 수도 있습니다.인터페이스 또는 특정 파이프에 할당된 대역폭 변경. 이러한 변경을 수행하려면인터페이스 또는 파이프는 각각 유휴 상태여야 합니다





호스트의 정확히 하나의 클라이언트가 지정된 인터페이스를 관리합니다. 클라이언트는 인터페이스의 각 파이프를 다음과 같이 초기화합니다.해당 파이프에 대한 정책을 설정합니다. 여기에는 IRP당 전송할 최대 데이터 양이 포함되며,파이프의 최대 서비스 간격. 서비스 간격은 밀리초로 표시되며 다음을 설명합니다.IRP의 데이터가 등시성 파이프에 대해 전송되는 간격입니다. 투표에 대해 설명합니다.인터럽트 파이프의 간격. 지정된 요청이 완료되면 클라이언트에 알립니다. 클라이언트듀티 사이클 및 대기 시간 제약이 유지되도록 각 IRP의 크기를 관리합니다. 추가의정책 정보에는 클라이언트에 대한 알림 정보가 포함됩니다.클라이언트는 전송된 데이터를 유지하는 데 필요한 버퍼 공간을 제공합니다. USB 시스템은 정책을 사용합니다.필요한 추가 작업 공간을 결정합니다.클라이언트는 자신의 데이터를 연속적인 직렬 스트림으로 보고 이를 유사한 방식으로 관리합니다.다른 유형의 버스 기술을 통해 제공되는 스트림. 내부적으로 USB 시스템은자체 정책 및 모든 호스트 컨트롤러 제약 조건에 따라 클라이언트 요청을 더 작은 요청으로 나눕니다.USB를 통해 전송됩니다. 그러나 USB 시스템이 선택할 때마다 두 가지 요구 사항이 충족되어야 합니다.다음과 같은 분할을 수행합니다.•데이터 스트림을 더 작은 청크로 나누는 것은 클라이언트에 표시되지 않습니다.•USB 샘플은 버스 트랜잭션 간에 분할되지 않습니다.클라이언트가 데이터 전송을 원할 때 IRP를 USBD로 보냅니다. 데이터의 방향에 따라전송, 전체 또는 빈 데이터 버퍼가 제공됩니다. 요청이 완료되면(성공적으로 또는오류 조건), IRP 및 해당 상태가 클라이언트에 반환됩니다. 관련이 있는 경우 이 상태도거래별로 제공됩니



다음 데이터 요소는 요청에 대한 관련 정보를 정의합니다.•요청과 연결된 파이프의 ID입니다. 이 파이프를 식별하면 정보도 설명됩니다.이 요청에 대한 전송 유형과 같은.•특정 클라이언트에 대한 알림 식별입니다.•전송 또는 수신할 데이터 버퍼의 위치 및 길이입니다.•요청의 완료 상태입니다. 요약 상태와 필요에 따라 거래별 세부 정보상태를 제공해야 합니다.•작업 공간의 위치와 길이. 이것은 구현에 따라 다릅니다



10.4 호스트 컨트롤러 드라이버호스트 컨트롤러 드라이버(HCD)는 호스트 컨트롤러 하드웨어와 호스트 컨트롤러의USB를 통한 데이터 전송 보기. HCDI는 다음 요구 사항을 충족합니다.•호스트 컨트롤러 하드웨어의 추상화를 제공합니다.•USB 상호 연결을 통한 호스트 컨트롤러의 데이터 전송에 대한 추상화를 제공합니다.•지원하기 위해 호스트 컨트롤러 리소스의 할당(및 할당 해제)을 위한 추상화를 제공합니다.USB 장치에 대한 보장된 서비스



10.5.1.2 USBD 파이프 사용파이프는 장치 끝점이 호스트 소프트웨어 엔터티와 연결되는 방법입니다. 파이프는호스트에서 정확히 하나의 해당 엔터티가 소유합니다. 파이프의 기본 개념은 어떤 경우에도 동일하지만소유자, USBD 클라이언트에 제공되는 기능의 일부 구별은 두 그룹 간에 발생합니다.파이프:•USBD가 소유하고 관리하는 기본 파이프•USBD의 클라이언트가 소유하고 관리하는 기타 모든 파이프기본 파이프는 클라이언트가 직접 액세스하지 않지만 일부를 수행하는 데 자주 사용됩니다.명령 메커니즘을 통해 중계되는 클라이언트 요청




10.5.1.2 USBD 파이프 사용파이프는 장치 끝점이 호스트 소프트웨어 엔터티와 연결되는 방법입니다. 파이프는호스트에서 정확히 하나의 해당 엔터티가 소유합니다. 파이프의 기본 개념은 어떤 경우에도 동일하지만소유자, USBD 클라이언트에 제공되는 기능의 일부 구별은 두 그룹 간에 발생합니다.파이프:•USBD가 소유하고 관리하는 기본 파이프•USBD의 클라이언트가 소유하고 관리하는 기타 모든 파이프기본 파이프는 클라이언트가 직접 액세스하지 않지만 일부를 수행하는 데 자주 사용됩니다.명령 메커니즘을 통해 중계되는 클라이언트 요청
=> 소유는 그럿지만 실제 사용할 버퍼는 유에스비 드랑이버에[서 정해주고 구현상의 실체이다.
=> 도메인으로 구현할 LogicalChannel의 실체는 버퍼



10.5.1.2.1 기본 파이프USBD는 전송을 지원하기 위해 적절한 버퍼링을 할당하고 관리하는 역할을 합니다.장치 주소 설정과 같이 클라이언트에 직접 표시되지 않는 기본 파이프. 이러한 전송을 위해공급업체 및 클래스 명령을 보내거나 장치를 읽는 것과 같이 클라이언트에서 직접 볼 수 있는 것설명자에서 클라이언트는 필요한 버퍼링을 제공해야 합니다.10.5.1.2.2 클라이언트 파이프USBD가 소유하고 관리하지 않는 모든 파이프는 USBD 클라이언트가 소유하고 관리할 수 있습니다. 로부터USBD 관점, 단일 클라이언트가 파이프를 소유합니다. 사실, 협력적인 클라이언트 그룹은 파이프를 관리할 수 있으며,파이프를 사용할 때 단일 조정 엔터티로 동작하는 경우에 한합니다.클라이언트는 데이터 전송 속도를 서비스하는 데 필요한 버퍼링 양을 제공할 책임이 있습니다.클라이언트가 도달할 수 있는 서비스 간격 내의 파이프. 작업을 위한 추가 버퍼링 요구 사항공간은 USB 시스템에 의해 지정됩



USBD 파이프 상태에는 두 가지 구성 요소가 있습니다.•호스트 상태•반영된 엔드포인트 상태파이프 상태가 보고될 때마다 두 구성 요소의 값이 식별됩니다. 파이프 상태끝점에서 반영된 것은 끝점이 특정 상태에 있는 결과입니다. USBD 클라이언트USBD에서 보고한 대로 파이프 상태를 관리합니다. 끝점에서 반영된 모든 파이프 상태에 대해 클라이언트는상태를 변경하려면 끝점과도 상호 작용해야 합니다.USBD 파이프는 정확히 다음 상태 중 하나에 있습니다.•활성: 파이프의 정책이 설정되었으며 파이프가 데이터를 전송할 수 있습니다. 클라이언트는 다음과 같이 쿼리할 수 있습니다.특정 파이프에 대해 미결 상태인 IRP가 있는지 여부. 미결제 IRP가 없는 파이프새 IRP를 수락할 수 있는 한 여전히 활성 상태로 간주됩니다.•중지됨: 파이프에 오류가 발생했습니다. 이 상태는 또한 해당장치에서 중지된 끝점입니다.파이프 및 끝점은 장치가 구성되고 파이프 및/또는 끝점이 다음과 같을 때 활성으로 간주됩니다.정지되지 않았습니다. 클라이언트는 다음과 같은 방법으로 파이프 상태를 조작할 수 있습니다.•파이프 중단: 파이프에 대해 예약된 모든 IRP는 즉시 폐기되고 클라이언트에게 반환됩니다.중단되었음을 나타내는 상태로 표시됩니다. 호스트 상태도 반영된 엔드포인트 상태도 아닙니다.파이프의 영향을 받습니다.•파이프 재설정: 파이프의 IRP가 중단됩니다. 호스트 상태가 활성으로 이동됩니다. 반사된 경우USBD 클라이언트에서 명시적으로 명령해야 하는 엔드포인트 상태를 변경해야 합니다.•중단된 파이프 지우기: 파이프의 상태가 Halted 에서 Active 로 지워집니다 .•파이프 중지: 파이프의 상태가 Halted 로 설정됩니


10.5.2.3 설명자 가져오기USBDI는 다음과 같이 표준 장치, 구성 및 문자열 설명자를 검색하는 메커니즘을 제공해야 합니다.클래스 또는 공급업체별 설명자도 포함됩니다.10.5.2.4 현재 구성 설정 가져오기USBDI는 지정된 장치에 대해 현재 구성 설명자를 반환하는 기능을 제공해야 합니다.장치가 구성되지 않은 경우 구성 설명자가 반환되지 않습니다. 이 조치는 다음과 같습니다.특정 구성을 요청하여 현재 구성에 대한 구성 설명자를 반환설명자. 그러나 클라이언트가 현재 구성의 식별자를 알 필요는 없습니다.그러면 다음을 포함한 모든 구성 정보가 반환됩니다.•모든 대체 정보를 포함하여 장치에 저장된 모든 구성 설명자 정보모든 인터페이스에 대한 설정•인터페이스에 대한 대체 설정이 활성화되어 있는 표시기•인터페이스에 대한 활성 대체 설정의 끝점에 대한 파이프 핸들•인터페이스에 대한 활성 대체 설정의 엔드포인트에 대한 실제 wMaxPacketSize 값또한 지정된 파이프에 대해 USBDI는 다음을 나타내는 wMaxPacketSize 를 반환하는 기능을 제공해야 합니다.현재 파이프에서 사용 중입니다



10.5.4.2 전원 제어USB에는 버스 및 장치 수준 관리라는 두 가지 협력 수준의 전원 관리가 있습니다.이 사양은 USB 버스의 전원을 관리하기 위한 메커니즘을 제공합니다. 장치 클래스는 다음을 정의할 수 있습니다.클래스별 전원 제어 기능.모든 USB 장치는 Suspended 상태를 지원해야 합니다(9장 참조). 장치는장치가 연결된 허브 포트의 제어를 통해 일시 중단된 상태입니다. 정상적인 장치 작동 중지정지 상태에서; 그러나 장치가 웨이크업 신호를 할 수 있고 장치가 다음을 위해 활성화된 경우원격 웨이크업, 외부 이벤트에 대한 응답으로 재개 신호를 생성할 수 있습니다.전원 관리 시스템은 장치를 일시 중단 상태로 전환하거나 다음 시간에 장치의 전원을 끌 수 있습니다.권력을 통제하고 보존하기 위해서다. USB는 장치에 대한 요구 사항이나 명령을 제공하지 않습니다.상태는 이러한 전환에 걸쳐 저장 및 복원됩니다. 장치 클래스는 클래스별 장치 상태를 정의할 수 있습니다.저장 및 복원 기능
=> 전원을 끄거나 서스펜드로 만드는일도 유에스비 드라이버가 해야함 => 깨우는것도(원격웨이크업 Remote Wakeup)